<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[禅与Objective-C编程艺术-4(翻译中)]]></title>
      <url>%2F2016%2F06%2F25%2F2016-06-25-Zen-OC-Art-4%2F</url>
      <content type="text"><![CDATA[编程和「禅」有关系吗?Zen and the Art of the Objective-C Craftsmanship译文兼笔记本章包含规范：对象通讯、代理和数据源、AOP 对象间通讯对象之间相互交流来实现复杂的需求，这是大部分软件的基础。这一节是关于深入阐述如何实现良好架构的设计理念以及如何使用他们。 BlocksBlock 是 Objective-C 中的闭包，相当于其他语言中的 lambda 或 closure。 可以像下面定义异步 API： - (void)downloadObjectsAtPath:(NSString *)path completion:(void(^)(NSArray *objects, NSError *error))completion; 当像上述来设计代码时，尽量在定义函数和方法的时候只用一个 block，而且最好放在最后一个参数的位置。把需要提供的数据和错误整合在一个 block 中，而不是两个分开的 block(通常一个是成功 block 和失败 block)。 为什么这么做： 通常部分代码在成功和失败之间是公共的(例如：移除进度条或者提示) Apple 官方也是这么做的，与平台一直有一些潜在的好处 鉴于 block 通常会是多行，不放在最后的话会打破调用点 使用多个 block 会在调用的长度长显得笨重，并且增加了复杂性 综上所述，书写完成的 block 就变的很简单：第一个参数为调用者想要的数据，第二个参数是错误的相关信息。这里需要遵循以下几点： 如果 objects 非 nil，则 error 必为 nil 如果 objects 为 nil，则 error 必非 nil 因为调用者更关心的是实际数据，推荐如下的实现方式： - (void)downloadObjectsAtPath:(NSString *)path completion:(void(^)(NSArray *objects, NSError *error))completion &#123; if (objects) &#123; // do something with the data &#125; else &#123; // some error occurred, &apos;error&apos; variable should not be nil by contract &#125;&#125; 此外，在一些异步方法中，Apple 的 API 在成功的回调中 error 参数写入了一些垃圾值(如果非 NULL)，所以检测 error 可能会不准确。 深入 block一些关键点： block 是在栈上创建的 block 可以复制到堆上 block 会捕获栈上的变量（或指针），复制为私有 const 想要修改栈上的变量和指针，那就必须要用 __block 关键字声明 如果 block 没有在其他在他位置被持有，生命周期与当前栈帧相同。当 block 在栈中时，block 对其访问的对象的存储和生命周期没有任何影响。如果 block 需要在栈帧返回之后还不被释放，它需要被通过确切的操作来复制到堆上。这样一个 block 会像其他 cocoa 对象一个增加引用计数。当 block 被复制的时候，它会带着其作用域内的对象一起增加引用计数。 如果 block 引用了一个栈上的变量或指针，接着当 block 被初始化的时候会持有这个变量或指针的 const 副本，所以再去为这些变量或指针赋值是没用的。当一个 block 被复制后，__block 声明的栈变量的引用被复制到了堆中，复制操作之后，无论是栈上的 block 还是刚刚复制的新的在堆上的 block 都会引用该变量在堆上的副本。 用 LLDB 来展示 block： 要注意最重要的点是，__block 修饰的变量或指针会被当做结构体，来处理引用的实际值或者对象。 block 在 Objective-C 的 runtime 中被寄予重要地位:他们有一个定义一个类的 isa 指针，Objective-C runtime 可以通过这个指针来访问方法和存储数据。在非 ARC 环境下你肯定会弄得一团糟，并且因为空指针导致崩溃。__block 适用于在 block 中使用的变量，它相当于在跟 block 说： 嗨，这个指针或原始类型在栈上有自己的地址。请在栈上再创建一个指针来引用它。我是说，对这个对象做两次间接引用，但是不要 retain 它。 谢谢。 如果有时候，在定义了 block 但是还没有被调用之前就把对象释放了，执行 block 会导致崩溃。__block 变量不会在 block 中被持有。最后…指针、引用、间接引用和引用计数就都乱了。 Retain cycles on selfIt’s important not to get into retain cycles when using blocks and asynchronous dispatches. Always set a weak reference to any variable that could cause a retain cycle. Moreover, it is a good practice to nil the properties holding the blocks (i.e. self.completionBlock = nil) this will break potential retain cycle introduced by the block capturing the scope. Example: __weak __typeof(self) weakSelf = self;[self executeBlock:^(NSData *data, NSError *error) &#123; [weakSelf doSomethingWithData:data];&#125;]; Not: [self executeBlock:^(NSData *data, NSError *error) &#123; [self doSomethingWithData:data];&#125;]; Example with multiple statements: __weak __typeof(self)weakSelf = self;[self executeBlock:^(NSData *data, NSError *error) &#123; __strong __typeof(weakSelf) strongSelf = weakSelf; if (strongSelf) &#123; [strongSelf doSomethingWithData:data]; [strongSelf doSomethingWithData:data]; &#125;&#125;]; Not: __weak __typeof(self)weakSelf = self;[self executeBlock:^(NSData *data, NSError *error) &#123; [weakSelf doSomethingWithData:data]; [weakSelf doSomethingWithData:data];&#125;]; You should add these two lines as snippets to Xcode and always use them exactly like this: __weak __typeof(self)weakSelf = self;__strong __typeof(weakSelf)strongSelf = weakSelf; Here we dig further about the subtle things to consider about the __weak and the __strong qualifiers for self inside blocks. To summarize, we can refer to self in three different ways inside a block: using the keyword self directly inside the block declaring a __weak reference to self outside the block and referring to the object via this weak reference inside the block declaring a __weak reference to self outside the block and creating a __strong reference to self using the weak reference inside the block Case 1: using the keyword self inside a block If we use directly the keyword self inside a block, the object is retained at block declaration time within the block (actually when the block is copied but for sake of simplicity we can forget about it) . A const reference to self has its place inside the block and this affects the reference counting of the object. If the block is used by other classes and/or passed around we may want to retain self as well as all the other objects used by the block since they are needed for the execution of the block. dispatch_block_t completionBlock = ^&#123; NSLog(@&quot;%@&quot;, self);&#125;MyViewController *myController = [[MyViewController alloc] init...];[self presentViewController:myController animated:YES completion:completionHandler]; No big deal. But… what if the block is retained by self in a property (as the following example) and therefore the object (self) retains the block? self.completionHandler = ^&#123; NSLog(@&quot;%@&quot;, self);&#125;MyViewController *myController = [[MyViewController alloc] init...];[self presentViewController:myController animated:YES completion:self.completionHandler]; This is what is well known as a retain cycle and retain cycles usually should be avoided. The warning we receive from CLANG is: Capturing &apos;self&apos; strongly in this block is likely to lead to a retain cycle Here comes in the __weak qualifier. Case 2: declaring a __weak reference to self outside the block and use it inside the block Declaring a __weak reference to self outside the block and referring to it via this weak reference inside the block avoids retain cycles. This is what we usually want to do if the block is already retained by self in a property. __weak typeof(self) weakSelf = self;self.completionHandler = ^&#123; NSLog(@&quot;%@&quot;, weakSelf);&#125;;MyViewController *myController = [[MyViewController alloc] init...];[self presentViewController:myController animated:YES completion:self.completionHandler]; In this example the block does not retain the object and the object retains the block in a property. Cool. We are sure that we can refer to self safely, at worst, it is nilled out by someone. The question is: how is it possible for self to be “destroyed” (deallocated) within the scope of a block? Consider the case of a block being copied from an object to another (let’s say myController) as a result of the assignment of a property. The former object is then released before the copied block has had a chance to execute. The next step is interesting. Case 3: declaring a __weak reference to self outside the block and use a __strong reference inside the block You may think, at first, this is a trick to use self inside the block avoiding the retain cycle warning. This is not the case. The strong reference to self is created at block execution time while using self in the block is evaluated at block declaration time, thus retaining the object. Apple documentation reports that “For non-trivial cycles, however, you should use” this approach: MyViewController *myController = [[MyViewController alloc] init...];// ...MyViewController * __weak weakMyController = myController;myController.completionHandler = ^(NSInteger result) &#123; MyViewController *strongMyController = weakMyController; if (strongMyController) &#123; // ... [strongMyController dismissViewControllerAnimated:YES completion:nil]; // ... &#125; else &#123; // Probably nothing... &#125;&#125;; First of all, this example looks wrong to me. How can self be deallocated and be nilled out if the block itself is retained in the completionHandler property? The completionHandler property can be declared as assign or unsafe_unretained to allow the object to be deallocated after the block is passed around.I can’t see the reason for doing that. If other objects need the object (self), the block that is passed around should retain the object and therefore the block should not be assigned to a property. No __weak/__strong usage should be involved in this case. Anyway, in other cases it is possible for weakSelf to become nil just like the second case explained (declaring a weak reference outside the block and use it inside). Moreover, what is the meaning of “trivial block” for Apple? It is my understanding that a trivial block is a block that is not passed around, it’s used within a well defined and controlled scope and therefore the usage of the weak qualifier is just to avoid a retain cycle. As a lot of online references, books (Effective Objective-C 2.0 by Matt Galloway and Pro Multithreading and Memory Management for iOS and OS X by Kazuki Sakamoto &amp; Tomohiko Furumoto) discuss this edge case, the topic is not well understood yet by the majority of the developers. The real benefit of using the strong reference inside of a block is to be robust to preemption. Going again through the above 3 cases, during the execution of a block: Case 1: using the keyword self inside a block If the block is retained by a property, a retain cycle is created between self and the block and both objects can’t be destroyed anymore. If the block is passed around and copied by others, self is retained for each copy. Case 2: declaring a __weak reference to self outside the block and use it inside the block There is no retain cycle and no matter if the block is retained or not by a property. If the block is passed around and copied by others, when executed, weakSelf can have been turned nil.The execution of the block can be preempted and different subsequent evaluations of the weakSelf pointer can lead to different values (i.e. weakSelf can become nil at a certain evaluation). __weak typeof(self) weakSelf = self;dispatch_block_t block = ^&#123; [weakSelf doSomething]; // weakSelf != nil // preemption, weakSelf turned nil [weakSelf doSomethingElse]; // weakSelf == nil&#125;; Case 3: declaring a __weak reference to self outside the block and use a __strong reference inside the block There is no retain cycle and, again, no matter if the block is retained or not by a property. If the block is passed around and copied by others, when executed, weakSelf can have been turned nil. When the strong reference is assigned and it is not nil, we are sure that the object is retained for the entire execution of the block if preemption occurs and therefore subsequent evaluations of strongSelf will be consistent and will lead to the same value since the object is now retained. If strongSelf evaluates to nil usually the execution is returned since the block cannot execute properly. __weak typeof(self) weakSelf = self;myObj.myBlock = ^&#123; __strong typeof(self) strongSelf = weakSelf; if (strongSelf) &#123; [strongSelf doSomething]; // strongSelf != nil // preemption, strongSelf still not nil [strongSelf doSomethingElse]; // strongSelf != nil &#125; else &#123; // Probably nothing... return; &#125;&#125;; In an ARC-based environment, the compiler itself alerts us with an error if trying to access an instance variable using the -&gt; notation. The error is very clear: Dereferencing a __weak pointer is not allowed due to possible null value caused by race condition, assign it to a strong variable first. It can be shown with the following code: __weak typeof(self) weakSelf = self;myObj.myBlock = ^&#123; id localVal = weakSelf-&gt;someIVar;&#125;; In the very end: Case 1: should be used only when the block is not assigned to a property, otherwise it will lead to a retain cycle. Case 2: should be used when the block is assigned to a property. Case 3: it is related to concurrent executions. When asynchronous services are involved, the blocks that are passed to them can be executed at a later period and there is no certainty about the existence of the self object. Delegate and DataSourceDelegation is a widespread pattern throughout Apple’s frameworks and it is one of the most important patterns in the Gang of Four’s book “Design Patterns”. The delegation pattern is unidirectional, the message sender (the delegant) needs to know about the recipient (the delegate), but not the other way around. The coupling between the objects is loosen the sender only knows that its delegate conforms to a specific protocol. In its pure form, delegation is about providing callbacks to the delegate, which means that the delegate implements a set of methods with void return type. Unfortunately this has not been respected over years by the APIs from Apple and therefore developers acted imitating this misleading approach. A classic example is the UITableViewDelegate protocol. While some methods have void return type and look like callbacks: - (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath;- (void)tableView:(UITableView *)tableView didHighlightRowAtIndexPath:(NSIndexPath *)indexPath; others are definitely not: - (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath;- (BOOL)tableView:(UITableView *)tableView canPerformAction:(SEL)action forRowAtIndexPath:(NSIndexPath *)indexPath withSender:(id)sender; When the delegant asks for some kind of information to the delegate object, the direction implied is from the delegate to the delegant and to the other way around anymore. This is conceptually different and a new name should be use to describe the pattern: DataSource. One could argue that Apple has a UITableViewDataSouce protocol for it (forced under the name of the delegate pattern) but in reality it is used for methods providing information about how the real data should be presented. - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath;- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView; Moreover, in the above 2 methods Apple mixed the presentation layer with the data layer which is clearly ugly and in the end very few developers felt bad about it over times and even here we’ll call delegate methods both methods with void return type and not void for simplicity. To split the concepts, the following approach should be used: delegate pattern: when the delegant needs to notify the delegate about event occurred datasource pattern: when the delegant needs to fetch information from the datasource object Here is a concrete example: @class ZOCSignUpViewController;@protocol ZOCSignUpViewControllerDelegate &lt;NSObject&gt;- (void)signUpViewControllerDidPressSignUpButton:(ZOCSignUpViewController *)controller;@end@protocol ZOCSignUpViewControllerDataSource &lt;NSObject&gt;- (ZOCUserCredentials *)credentialsForSignUpViewController:(ZOCSignUpViewController *)controller;@end@protocol ZOCSignUpViewControllerDataSource &lt;NSObject&gt;@interface ZOCSignUpViewController : UIViewController@property (nonatomic, weak) id&lt;ZOCSignUpViewControllerDelegate&gt; delegate;@property (nonatomic, weak) id&lt;ZOCSignUpViewControllerDataSource&gt; dataSource;@end Delegate methods should be always have the caller as first parameter as in the above example otherwise delegate objects could not be able to distinguish between different instances of delegants. In other words, if the caller is not passed to the delegate object, there would be no way for any delegate to deal with 2 delegant object. So, following is close to blasphemy: - (void)calculatorDidCalculateValue:(CGFloat)value; By default, methods in protocols are required to be implemented by delegate objects. It is possible to mark some of them as optional and to be explicit about the required method using the @required and @optional keywords as so: @protocol ZOCSignUpViewControllerDelegate &lt;NSObject&gt;@required- (void)signUpViewController:(ZOCSignUpViewController *)controller didProvideSignUpInfo:(NSDictionary *);@optional- (void)signUpViewControllerDidPressSignUpButton:(ZOCSignUpViewController *)controller;@end For optional methods, the delegant must check if the delegate actually implements a specific method before sending the message to it (otherwise a crash would occur) as so: if ([self.delegate respondsToSelector:@selector(signUpViewControllerDidPressSignUpButton:)]) &#123; [self.delegate signUpViewControllerDidPressSignUpButton:self];&#125; InheritanceSometimes you may need to override delegate methods. Consider the case of having two UIViewController subclasses: UIViewControllerA and UIViewControllerB, with the following class hierarchy. UIViewControllerB &lt; UIViewControllerA &lt; UIViewController UIViewControllerA conforms to UITableViewDelegate and implements - (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath. You want to provide a different implementation for the method above in UIViewControllerB. An implementation like the following will work: - (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath &#123; CGFloat retVal = 0; if ([super respondsToSelector:@selector(tableView:heightForRowAtIndexPath:)]) &#123; retVal = [super tableView:self.tableView heightForRowAtIndexPath:indexPath]; &#125; return retVal + 10.0f;&#125; But what if the given method was not implemented in the superclass (UIViewControllerA)? The invocation [super respondsToSelector:@selector(tableView:heightForRowAtIndexPath:)] will use the NSObject’s implementation that will lookup, under the hood, in the context of self and clearly self implements the method but the app will crash at the next line with the following error: *** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[UIViewControllerB tableView:heightForRowAtIndexPath:]: unrecognized selector sent to instance 0x8d82820' In this case we need to ask if instances of a specific class can respond to a given selector. The following code would do the trick: - (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath &#123; CGFloat retVal = 0; if ([[UIViewControllerA class] instancesRespondToSelector:@selector(tableView:heightForRowAtIndexPath:)]) &#123; retVal = [super tableView:self.tableView heightForRowAtIndexPath:indexPath]; &#125; return retVal + 10.0f;&#125; As code as the one above is ugly, often it’d be better to design the architecture in a way that delegate methods don’t need to be overridden. Multiple DelegationMultiple delegation is a very fundamental concept that, unfortunately, the majority of developers are hardly familiar with and too often NSNotifications are used instead. As you may have noticed, delegation and datasource are inter-object communication pattern involving only 2 objects: 1 delegant and 1 delegate. DataSource pattern is forced to be 1 to 1 as the information the sender asks for can be provided by one and only one object. Things are different for the delegate pattern and it would be perfectly reasonable to have many delegate objects waiting for the callbacks. There are cases where at least 2 objects are interested in receiving the callbacks from a particular delegant and the latter wants to know all of its delegates. This approach maps better a distributed system and more generically how complex flows of information usually go in wide software. Multiple delegation can be achieved in many ways and the reader is dared to find a proper personal implementation. A very neat implementation of multiple delegation using the forward mechanism is given by Luca Bernardi in his LBDelegateMatrioska. A basic implementation is given here to unfold the concept. Even if in Cocoa there are ways to store weak references in a data structure to avoid retain cycles, here we use a class to hold a weak reference to the delegate object as single delegation does. @interface ZOCWeakObject : NSObject@property (nonatomic, weak, readonly) id object;+ (instancetype)weakObjectWithObject:(id)object;- (instancetype)initWithObject:(id)object;@end @interface ZOCWeakObject ()@property (nonatomic, weak) id object;@end@implementation ZOCWeakObject+ (instancetype)weakObjectWithObject:(id)object &#123; return [[[self class] alloc] initWithObject:object];&#125;- (instancetype)initWithObject:(id)object &#123; if ((self = [super init])) &#123; _object = object; &#125; return self;&#125;- (BOOL)isEqual:(id)object &#123; if (self == object) &#123; return YES; &#125; if (![object isKindOfClass:[object class]]) &#123; return NO; &#125; return [self isEqualToWeakObject:(ZOCWeakObject *)object];&#125;- (BOOL)isEqualToWeakObject:(ZOCWeakObject *)object &#123; if (!object) &#123; return NO; &#125; BOOL objectsMatch = [self.object isEqual:object.object]; return objectsMatch;&#125;- (NSUInteger)hash &#123; return [self.object hash];&#125;@end A simple component using weak objects to achieve multiple delegation: @protocol ZOCServiceDelegate &lt;NSObject&gt;@optional- (void)generalService:(ZOCGeneralService *)service didRetrieveEntries:(NSArray *)entries;@end@interface ZOCGeneralService : NSObject- (void)registerDelegate:(id&lt;ZOCServiceDelegate&gt;)delegate;- (void)deregisterDelegate:(id&lt;ZOCServiceDelegate&gt;)delegate;@end@interface ZOCGeneralService ()@property (nonatomic, strong) NSMutableSet *delegates;@end @implementation ZOCGeneralService- (void)registerDelegate:(id&lt;ZOCServiceDelegate&gt;)delegate &#123; if ([delegate conformsToProtocol:@protocol(ZOCServiceDelegate)]) &#123; [self.delegates addObject:[[ZOCWeakObject alloc] initWithObject:delegate]]; &#125;&#125;- (void)deregisterDelegate:(id&lt;ZOCServiceDelegate&gt;)delegate &#123; if ([delegate conformsToProtocol:@protocol(ZOCServiceDelegate)]) &#123; [self.delegates removeObject:[[ZOCWeakObject alloc] initWithObject:delegate]]; &#125;&#125;- (void)_notifyDelegates &#123; ... for (ZOCWeakObject *object in self.delegates) &#123; if (object.object) &#123; if ([object.object respondsToSelector:@selector(generalService:didRetrieveEntries:)]) &#123; [object.object generalService:self didRetrieveEntries:entries]; &#125; &#125; &#125;&#125;@end With the registerDelegate: and deregisterDelegate: methods, it is easy to connect/disconnect cables between components: if at some point in time a delegate object is not interested in receiving the callbacks from a delegant, it has the chance to just ‘unsubscribe’.This can be useful when there are different views waiting for some callback to update the shown info: if a view is temporarily hidden (but still alive) it could make sense for it to just unsubscribe to those callbacks. Aspect Oriented ProgrammingAspect Oriented Programming (AOP) is something not well-known in the Objective-C community but it should be as the runtime is so powerful that AOP should be one of the first things that comes to the mind. Unfortunately, as there is no standard de facto library, nothing comes ready to use out-of-the-box from Apple and the topic is far from being trivial, developers still don’t think of it in nowadays. Quoting the Aspect Oriented Programming Wikipedia page: An aspect can alter the behavior of the base code (the non-aspect part of a program) by applying advice (additional behavior) at various join points (points in a program) specified in a quantification or query called a pointcut (that detects whether a given join point matches). In the world of Objective-C this means using the runtime features to add aspects to specific methods. The additional behaviors given by the aspect can be either: add code to be performed before a specific method call on a specific class add code to be performed after a specific method call on a specific class add code to be performed instead of the original implementation of a specific method call on a specific class There are many ways to achieve this we are not digging into deep here, basically all of them leverage the power of the runtime.Peter Steinberger wrote a library, Aspects that fits the AOP approach perfectly. We found it reliable and well-designed and we are going to use it here for sake of simplicity.As said for all the AOP-ish libraries, the library does some cool magic with the runtime, replacing and adding methods (further tricks over the method swizzling technique).The API of Aspect are interesting and powerful: + (id&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector withOptions:(AspectOptions)options usingBlock:(id)block error:(NSError **)error;- (id&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector withOptions:(AspectOptions)options usingBlock:(id)block error:(NSError **)error; For instance, the following code will perform the block parameter after the execution of the method myMethod: (instance or class method that be) on the class MyClass. [MyClass aspect_hookSelector:@selector(myMethod:) withOptions:AspectPositionAfter usingBlock:^(id&lt;AspectInfo&gt; aspectInfo) &#123; ... &#125; error:nil]; In other words: the code provided in the block parameter will always be executed after each call of the @selector parameter on any object of type MyClass (or on the class itself if the method is a class method). We added an aspect on MyClass for the method myMethod:. Usually AOP is used to implement cross cutting concern. Perfect example to leverage are analytics or logging. In the following we will present the use of AOP for analytics. Analytics are a popular “feature” to include in iOS projects, with a huge variety of choices ranging from Google Analytics, Flurry, MixPanel, etc.Most of them have tutorials describing how to track specific views and events including a few lines of code inside each class. On Ray Wenderlich’s blog there is a long article with some sample code to include in your view controller in order to track an event with Google Analytics: - (void)logButtonPress:(UIButton *)button &#123; id&lt;GAITracker&gt; tracker = [[GAI sharedInstance] defaultTracker]; [tracker send:[[GAIDictionaryBuilder createEventWithCategory:@&quot;UX&quot; action:@&quot;touch&quot; label:[button.titleLabel text] value:nil] build]];&#125; The code above sends an event with context information whenever a button is tapped. Things get worse when you want to track a screen view: - (void)viewDidAppear:(BOOL)animated &#123; [super viewDidAppear:animated]; id&lt;GAITracker&gt; tracker = [[GAI sharedInstance] defaultTracker]; [tracker set:kGAIScreenName value:@&quot;Stopwatch&quot;]; [tracker send:[[GAIDictionaryBuilder createAppView] build]];&#125; This should look like a code smell to the most of the experienced iOS developers. We are actually making the view controller dirty adding lines of code that should not belong there as it’s not responsibility of the view controller to track events. You could argue that you usually have a specific object responsible for analytics tracking and you inject this object inside the view controller but the problem is still there and no matter where you hide the tracking logic: you eventually end up inserting some lines of code in the viewDidAppear:. We can use AOP to track screen views on specific viewDidAppear: methods, and moreover, we could use the same approach to add event tracking in other methods we are interested in, for instance when the user taps on a button (i.e. trivially calling the corresponding IBAction). This approach is clean and unobtrusive: the view controllers will not get dirty with code that does not naturally belongs to them it becomes possible to specify a SPOC file (single point of customization) for all the aspects to add to our code the SPOC should be used to add the aspects at the very startup of the app if the SPOC file is malformed and at least one selector or class is not recognized, the app will crash at startup (which is cool for our purposes) the team in the company responsible for managing the analytics usually provides a document with the list of things to track; this document could then be easily mapped to a SPOC file as the logic for the tracking is now abstracted, it becomes possible to scale with a grater number of analytics providers for screen views it is enough to specify in the SPOC file the classes involved (the corresponding aspect will be added to the viewDidAppear: method), for events it is necessary to specify the selectors. To send both screen views and events, a tracking label and maybe extra meta data are needed to provide extra information (depending on the analytics provider). We may want a SPOC file similar to the following (also a .plist file would perfectly fit as well): NSDictionary *analyticsConfiguration()&#123; return @&#123; @&quot;trackedScreens&quot; : @[ @&#123; @&quot;class&quot; : @&quot;ZOCMainViewController&quot;, @&quot;label&quot; : @&quot;Main screen&quot; &#125; ], @&quot;trackedEvents&quot; : @[ @&#123; @&quot;class&quot; : @&quot;ZOCMainViewController&quot;, @&quot;selector&quot; : @&quot;loginViewFetchedUserInfo:user:&quot;, @&quot;label&quot; : @&quot;Login with Facebook&quot; &#125;, @&#123; @&quot;class&quot; : @&quot;ZOCMainViewController&quot;, @&quot;selector&quot; : @&quot;loginViewShowingLoggedOutUser:&quot;, @&quot;label&quot; : @&quot;Logout with Facebook&quot; &#125;, @&#123; @&quot;class&quot; : @&quot;ZOCMainViewController&quot;, @&quot;selector&quot; : @&quot;loginView:handleError:&quot;, @&quot;label&quot; : @&quot;Login error with Facebook&quot; &#125;, @&#123; @&quot;class&quot; : @&quot;ZOCMainViewController&quot;, @&quot;selector&quot; : @&quot;shareButtonPressed:&quot;, @&quot;label&quot; : @&quot;Share button&quot; &#125; ] &#125;;&#125; The architecture proposed is hosted on GitHub on the EF Education First profile. - (void)setupWithConfiguration:(NSDictionary *)configuration&#123; // screen views tracking for (NSDictionary *trackedScreen in configuration[@&quot;trackedScreens&quot;]) &#123; Class clazz = NSClassFromString(trackedScreen[@&quot;class&quot;]); [clazz aspect_hookSelector:@selector(viewDidAppear:) withOptions:AspectPositionAfter usingBlock:^(id&lt;AspectInfo&gt; aspectInfo) &#123; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; NSString *viewName = trackedScreen[@&quot;label&quot;]; [tracker trackScreenHitWithName:viewName]; &#125;); &#125;]; &#125; // events tracking for (NSDictionary *trackedEvents in configuration[@&quot;trackedEvents&quot;]) &#123; Class clazz = NSClassFromString(trackedEvents[@&quot;class&quot;]); SEL selektor = NSSelectorFromString(trackedEvents[@&quot;selector&quot;]); [clazz aspect_hookSelector:selektor withOptions:AspectPositionAfter usingBlock:^(id&lt;AspectInfo&gt; aspectInfo) &#123; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; UserActivityButtonPressedEvent *buttonPressEvent = [UserActivityButtonPressedEvent eventWithLabel:trackedEvents[@&quot;label&quot;]]; [tracker trackEvent:buttonPressEvent]; &#125;); &#125;]; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[史上最浅显易懂的Git教程]]></title>
      <url>%2F2016%2F02%2F18%2F2016-02-18-Git-Tutorial%2F</url>
      <content type="text"><![CDATA[史上最浅显易懂的Git教程这篇文章转载和整理自「原文」。 关于作者 廖雪峰，十年软件开发经验，业余产品经理，精通Java/Python/Ruby/Visual Basic/Objective C等，对开源框架有深入研究，著有《Spring 2.0核心技术与最佳实践》一书，多个业余开源项目托管在GitHub，欢迎微博交流： Git简介Git是什么？ Git是目前世界上最先进的分布式版本控制系统（没有之一）。 Git有什么特点？简单来说就是：高端大气上档次！ 那什么是版本控制系统？ 如果你用Microsoft Word写过长篇大论，那你一定有这样的经历： 想删除一个段落，又怕将来想恢复找不回来怎么办？有办法，先把当前文件“另存为……”一个新的Word文件，再接着改，改到一定程度，再“另存为……”一个新文件，这样一直改下去，最后你的Word文档变成了这样： 过了一周，你想找回被删除的文字，但是已经记不清删除前保存在哪个文件里了，只好一个一个文件去找，真麻烦。 看着一堆乱七八糟的文件，想保留最新的一个，然后把其他的删掉，又怕哪天会用上，还不敢删，真郁闷。 更要命的是，有些部分需要你的财务同事帮助填写，于是你把文件Copy到U盘里给她（也可能通过Email发送一份给她），然后，你继续修改Word文件。一天后，同事再把Word文件传给你，此时，你必须想想，发给她之后到你收到她的文件期间，你作了哪些改动，得把你的改动和她的部分合并，真困难。 于是你想，如果有一个软件，不但能自动帮我记录每次文件的改动，还可以让同事协作编辑，这样就不用自己管理一堆类似的文件了，也不需要把文件传来传去。如果想查看某次改动，只需要在软件里瞄一眼就可以，岂不是很方便？ 这个软件用起来就应该像这个样子，能记录每次文件的改动： 版本 用户 说明 日期 1 张三 删除了软件服务条款5 7/12 10:38 2 张三 增加了License人数限制 7/12 18:09 3 李四 财务部门调整了合同金额 7/13 9:51 4 张三 延长了免费升级周期 7/14 15:17 这样，你就结束了手动管理多个“版本”的史前时代，进入到版本控制的20世纪。 Git的诞生很多人都知道，Linus在1991年创建了开源的Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。 Linus虽然创建了Linux，但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？ 事实是，在2002年以前，世界各地的志愿者把源代码文件通过diff的方式发给Linus，然后由Linus本人通过手工方式合并代码！ 你也许会想，为什么Linus不把Linux代码放到版本控制系统里呢？不是有CVS、SVN这些免费的版本控制系统吗？因为Linus坚定地反对CVS和SVN，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比CVS、SVN好用，但那是付费的，和Linux的开源精神不符。 不过，到了2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。 安定团结的大好局面在2005年就被打破了，原因是Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个），被BitMover公司发现了（监控工作做得不错！），于是BitMover公司怒了，要收回Linux社区的免费使用权。 Linus可以向BitMover公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是这样的： Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！牛是怎么定义的呢？大家可以体会一下。 Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。 历史就是这么偶然，如果不是当年BitMover公司威胁Linux社区，可能现在我们就没有免费而超级好用的Git了。 集中式vs分布式Linus一直痛恨的CVS及SVN都是集中式的版本控制系统，而Git是分布式版本控制系统，集中式和分布式版本控制系统有什么区别呢？ 先说集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。 集中式版本控制系统最大的毛病就是必须联网才能工作，如果在局域网内还好，带宽够大，速度够快，可如果在互联网上，遇到网速慢的话，可能提交一个10M的文件就需要5分钟，这还不得把人给憋死啊。 那分布式版本控制系统与集中式版本控制系统有何不同呢？首先，分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。 和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。 在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了，也可能今天你的同事病了，他的电脑压根没有开机。因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。 当然，Git的优势不单是不必联网这么简单，后面我们还会看到Git极其强大的分支管理，把SVN等远远抛在了后面。 CVS作为最早的开源而且免费的集中式版本控制系统，直到现在还有不少人在用。由于CVS自身设计的问题，会造成提交文件不完整，版本库莫名其妙损坏的情况。同样是开源而且免费的SVN修正了CVS的一些稳定性问题，是目前用得最多的集中式版本库控制系统。 除了免费的外，还有收费的集中式版本控制系统，比如IBM的ClearCase（以前是Rational公司的，被IBM收购了），特点是安装比Windows还大，运行比蜗牛还慢，能用ClearCase的一般是世界500强，他们有个共同的特点是财大气粗，或者人傻钱多。 微软自己也有一个集中式版本控制系统叫VSS，集成在Visual Studio中。由于其反人类的设计，连微软自己都不好意思用了。 分布式版本控制系统除了Git以及促使Git诞生的BitKeeper外，还有类似Git的Mercurial和Bazaar等。这些分布式版本控制系统各有特点，但最快、最简单也最流行的依然是Git！ 安装Git最早Git是在Linux上开发的，很长一段时间内，Git也只能在Linux和Unix系统上跑。不过，慢慢地有人把它移植到了Windows上。现在，Git可以在Linux、Unix、Mac和Windows这几大平台上正常运行了。 要使用Git，第一步当然是安装Git了。根据你当前使用的平台来阅读下面的文字： 在Linux上安装Git首先，你可以试着输入git，看看系统有没有安装Git： $ gitThe program 'git' is currently not installed. You can install it by typing:sudo apt-get install git 像上面的命令，有很多Linux会友好地告诉你Git没有安装，还会告诉你如何安装Git。 如果你碰巧用Debian或Ubuntu Linux，通过一条sudo apt-get install git就可以直接完成Git的安装，非常简单。 老一点的Debian或Ubuntu Linux，要把命令改为sudo apt-get install git-core，因为以前有个软件也叫GIT（GNU Interactive Tools），结果Git就只能叫git-core了。由于Git名气实在太大，后来就把GNU Interactive Tools改成gnuit，git-core正式改为git。 如果是其他Linux版本，可以直接通过源码安装。先从Git官网下载源码，然后解压，依次输入：./config，make，sudo make install这几个命令安装就好了。 在Mac OS X上安装Git如果你正在使用Mac做开发，有两种安装Git的方法。 一是安装homebrew，然后通过homebrew安装Git，具体方法请参考homebrew的文档：http://brew.sh/。 第二种方法更简单，也是推荐的方法，就是直接从AppStore安装Xcode，Xcode集成了Git，不过默认没有安装，你需要运行Xcode，选择菜单“Xcode”-&gt;“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”就可以完成安装了。 Xcode是Apple官方IDE，功能非常强大，是开发Mac和iOS App的必选装备，而且是免费的！ 在Windows上安装Git实话实说，Windows是最烂的开发平台，如果不是开发Windows游戏或者在IE里调试页面，一般不推荐用Windows。不过，既然已经上了微软的贼船，也是有办法安装Git的。 Windows下要使用很多Linux/Unix的工具时，需要Cygwin这样的模拟环境，Git也一样。Cygwin的安装和配置都比较复杂，就不建议你折腾了。不过，有高人已经把模拟环境和Git都打包好了，名叫msysgit，只需要下载一个单独的exe安装程序，其他什么也不用装，绝对好用。 msysgit是Windows版的Git，从http://msysgit.github.io/下载，然后按默认选项安装即可。 安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！ 安装完成后，还需要最后一步设置，在命令行输入： $ git config --global user.name "Your Name"$ git config --global user.email "email@example.com" 因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。你也许会担心，如果有人故意冒充别人怎么办？这个不必担心，首先我们相信大家都是善良无知的群众，其次，真的有冒充的也是有办法可查的。 注意git config命令的--global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。 创建版本库什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。 所以，创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录： $ mkdir learngit$ cd learngit$ pwd/Users/michael/learngit pwd命令用于显示当前目录。在我的Mac上，这个仓库位于/Users/michael/learngit。 如果你使用Windows系统，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文。 第二步，通过git init命令把这个目录变成Git可以管理的仓库： $ git initInitialized empty Git repository in /Users/michael/learngit/.git/ 瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。 如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。 也不一定必须在空目录下创建Git仓库，选择一个已经有东西的目录也是可以的。不过，不建议你使用自己正在开发的公司项目来学习Git，否则造成的一切后果概不负责。 把文件添加到版本库首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。 不幸的是，Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的，前面我们举的例子只是为了演示，如果要真正使用版本控制系统，就要以纯文本方式编写文件。 因为文本是有编码的，比如中文有常用的GBK编码，日文有Shift_JIS编码，如果没有历史遗留问题，强烈建议使用标准的UTF-8编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。 使用Windows的童鞋要特别注意： 千万不要使用Windows自带的记事本编辑任何文本文件。原因是Microsoft开发记事本的团队使用了一个非常弱智的行为来保存UTF-8编码的文件，他们自作聪明地在每个文件开头添加了0xefbbbf（十六进制）的字符，你会遇到很多不可思议的问题，比如，网页第一行可能会显示一个“?”，明明正确的程序一编译就报语法错误，等等，都是由记事本的弱智行为带来的。建议你下载Notepad++代替记事本，不但功能强大，而且免费！记得把Notepad++的默认编码设置为UTF-8 without BOM即可： 言归正传，现在我们编写一个readme.txt文件，内容如下： Git is a version control system.Git is free software. 一定要放到learngit目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。 和把大象放到冰箱需要3步相比，把一个文件放到Git仓库只需要两步。 第一步，用命令git add告诉Git，把文件添加到仓库： $ git add readme.txt 执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。 第二步，用命令git commit告诉Git，把文件提交到仓库： $ git commit -m "wrote a readme file"[master (root-commit) cb926e7] wrote a readme file 1 file changed, 2 insertions(+) create mode 100644 readme.txt 简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。 嫌麻烦不想输入-m &quot;xxx&quot;行不行？确实有办法可以这么干，但是强烈不建议你这么干，因为输入说明对自己对别人阅读都很重要。实在不想输入说明的童鞋请自行Google，我不告诉你这个参数。 git commit命令执行成功后会告诉你，1个文件被改动（我们新添加的readme.txt文件），插入了两行内容（readme.txt有两行内容）。 为什么Git添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如： $ git add file1.txt$ git add file2.txt file3.txt$ git commit -m "add 3 files." 小结 现在总结一下今天学的两点内容： 初始化一个Git仓库，使用git init命令。 添加文件到Git仓库，分两步： 第一步，使用命令git add，注意，可反复多次使用，添加多个文件； 第二步，使用命令git commit，完成。 时光机穿梭我们已经成功地添加并提交了一个readme.txt文件，现在，是时候继续工作了，于是，我们继续修改readme.txt文件，改成如下内容： Git is a distributed version control system.Git is free software. 现在，运行git status命令看看结果： $ git status# On branch master# Changes not staged for commit:# (use "git add &lt;file&gt;..." to update what will be committed)# (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)## modified: readme.txt#no changes added to commit (use "git add" and/or "git commit -a") git status命令可以让我们时刻掌握仓库当前的状态，上面的命令告诉我们，readme.txt被修改过了，但还没有准备提交的修改。 虽然Git告诉我们readme.txt被修改了，但如果能看看具体修改了什么内容，自然是很好的。比如你休假两周从国外回来，第一天上班时，已经记不清上次怎么修改的readme.txt，所以，需要用git diff这个命令看看： $ git diff readme.txt diff --git a/readme.txt b/readme.txtindex 46d49bf..9247db6 100644--- a/readme.txt+++ b/readme.txt@@ -1,2 +1,2 @@-Git is a version control system.+Git is a distributed version control system. Git is free software. git diff顾名思义就是查看difference，显示的格式正是Unix通用的diff格式，可以从上面的命令输出看到，我们在第一行添加了一个“distributed”单词。 知道了对readme.txt作了什么修改后，再把它提交到仓库就放心多了，提交修改和提交新文件是一样的两步，第一步是git add： $ git add readme.txt 同样没有任何输出。在执行第二步git commit之前，我们再运行git status看看当前仓库的状态： $ git status# On branch master# Changes to be committed:# (use "git reset HEAD &lt;file&gt;..." to unstage)## modified: readme.txt# git status告诉我们，将要被提交的修改包括readme.txt，下一步，就可以放心地提交了： $ git commit -m "add distributed"[master ea34578] add distributed 1 file changed, 1 insertion(+), 1 deletion(-) 提交后，我们再用git status命令看看仓库的当前状态： $ git status# On branch masternothing to commit (working directory clean) Git告诉我们当前没有需要提交的修改，而且，工作目录是干净（working directory clean）的。 小结 要随时掌握工作区的状态，使用git status命令。 如果git status告诉你有文件被修改过，用git diff可以查看修改内容。 版本回退现在，你已经学会了修改文件，然后把修改提交到Git版本库，现在，再练习一次，修改readme.txt文件如下： Git is a distributed version control system.Git is free software distributed under the GPL. 然后尝试提交： $ git add readme.txt$ git commit -m "append GPL"[master 3628164] append GPL 1 file changed, 1 insertion(+), 1 deletion(-) 像这样，你不断对文件进行修改，然后不断提交修改到版本库里，就好比玩RPG游戏时，每通过一关就会自动把游戏状态存盘，如果某一关没过去，你还可以选择读取前一关的状态。有些时候，在打Boss之前，你会手动存盘，以便万一打Boss失败了，可以从最近的地方重新开始。Git也是一样，每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为commit。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个commit恢复，然后继续工作，而不是把几个月的工作成果全部丢失。 现在，我们回顾一下readme.txt文件一共有几个版本被提交到Git仓库里了： 版本1：wrote a readme file Git is a version control system.Git is free software. 版本2：add distributed Git is a distributed version control system.Git is free software. 版本3：append GPL Git is a distributed version control system.Git is free software distributed under the GPL. 当然了，在实际工作中，我们脑子里怎么可能记得一个几千行的文件每次都改了什么内容，不然要版本控制系统干什么。版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用git log命令查看： $ git logcommit 3628164fb26d48395383f8f31179f24e0882e1e0Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Tue Aug 20 15:11:49 2013 +0800 append GPLcommit ea34578d5496d7dd233c827ed32a8cd576c5ee85Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Tue Aug 20 14:53:12 2013 +0800 add distributedcommit cb926e7ea50ad11b8f9e909c05226233bf755030Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Mon Aug 19 17:51:55 2013 +0800 wrote a readme file git log命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是append GPL，上一次是add distributed，最早的一次是wrote a readme file。如果嫌输出信息太多，看得眼花缭乱的，可以试试加上--pretty=oneline参数： $ git log --pretty=oneline3628164fb26d48395383f8f31179f24e0882e1e0 append GPLea34578d5496d7dd233c827ed32a8cd576c5ee85 add distributedcb926e7ea50ad11b8f9e909c05226233bf755030 wrote a readme file 需要友情提示的是，你看到的一大串类似3628164...882e1e0的是commit id（版本号），和SVN不一样，Git的commit id不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的commit id和我的肯定不一样，以你自己的为准。为什么commit id需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。 每提交一个新版本，实际上Git就会把它们自动串成一条时间线。如果使用可视化工具查看Git历史，就可以更清楚地看到提交历史的时间线： 好了，现在我们启动时光穿梭机，准备把readme.txt回退到上一个版本，也就是“add distributed”的那个版本，怎么做呢？ 首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交3628164...882e1e0（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。 现在，我们要把当前版本“append GPL”回退到上一个版本“add distributed”，就可以使用git reset命令： $ git reset --hard HEAD^HEAD is now at ea34578 add distributed --hard参数有啥意义？这个后面再讲，现在你先放心使用。 看看readme.txt的内容是不是版本add distributed： $ cat readme.txtGit is a distributed version control system.Git is free software. 果然。 还可以继续回退到上一个版本wrote a readme file，不过且慢，然我们用git log再看看现在版本库的状态： $ git logcommit ea34578d5496d7dd233c827ed32a8cd576c5ee85Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Tue Aug 20 14:53:12 2013 +0800 add distributedcommit cb926e7ea50ad11b8f9e909c05226233bf755030Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Mon Aug 19 17:51:55 2013 +0800 wrote a readme file 最新的那个版本append GPL已经看不到了！好比你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，肿么办？ 办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个append GPL的commit id是3628164...，于是就可以指定回到未来的某个版本： $ git reset --hard 3628164HEAD is now at 3628164 append GPL 版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。 再小心翼翼地看看readme.txt的内容： $ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL. 果然，我胡汉三又回来了。 Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD从指向append GPL： 改为指向add distributed： 然后顺便把工作区的文件更新了。所以你让HEAD指向哪个版本号，你就把当前版本定位在哪。 现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？ 在Git中，总是有后悔药可以吃的。当你用$ git reset --hard HEAD^回退到add distributed版本时，再想恢复到append GPL，就必须找到append GPL的commit id。Git提供了一个命令git reflog用来记录你的每一次命令： $ git reflogea34578 HEAD@&#123;0&#125;: reset: moving to HEAD^3628164 HEAD@&#123;1&#125;: commit: append GPLea34578 HEAD@&#123;2&#125;: commit: add distributedcb926e7 HEAD@&#123;3&#125;: commit (initial): wrote a readme file 终于舒了口气，第二行显示append GPL的commit id是3628164，现在，你又可以乘坐时光机回到未来了。 小结 现在总结一下： HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。 穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。 工作区和暂存区Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。 先来看名词解释。 工作区（Working Directory）就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区： 版本库（Repository）工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。 Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。 分支和HEAD的概念我们以后再讲。 前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的： 第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区； 第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。 因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。 你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。 俗话说，实践出真知。现在，我们再练习一遍，先对readme.txt做个修改，比如加上一行内容： Git is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage. 然后，在工作区新增一个LICENSE文本文件（内容随便写）。 先用git status查看一下状态： $ git status# On branch master# Changes not staged for commit:# (use "git add &lt;file&gt;..." to update what will be committed)# (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)## modified: readme.txt## Untracked files:# (use "git add &lt;file&gt;..." to include in what will be committed)## LICENSEno changes added to commit (use "git add" and/or "git commit -a") Git非常清楚地告诉我们，readme.txt被修改了，而LICENSE还从来没有被添加过，所以它的状态是Untracked。 现在，使用两次命令git add，把readme.txt和LICENSE都添加后，用git status再查看一下： $ git status# On branch master# Changes to be committed:# (use "git reset HEAD &lt;file&gt;..." to unstage)## new file: LICENSE# modified: readme.txt# 现在，暂存区的状态就变成这样了： 所以，git add命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行git commit就可以一次性把暂存区的所有修改提交到分支。 $ git commit -m "understand how stage works"[master 27c9860] understand how stage works 2 files changed, 675 insertions(+) create mode 100644 LICENSE 一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的： $ git status# On branch masternothing to commit (working directory clean) 现在版本库变成了这样，暂存区就没有任何内容了： 小结 暂存区是Git非常重要的概念，弄明白了暂存区，就弄明白了Git的很多操作到底干了什么。 没弄明白暂存区是怎么回事的童鞋，请向上滚动页面，再看一次。 管理修改现在，假定你已经完全掌握了暂存区的概念。下面，我们要讨论的就是，为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。 你会问，什么是修改？比如你新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。 为什么说Git管理的是修改，而不是文件呢？我们还是做实验。第一步，对readme.txt做一个修改，比如加一行内容： $ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes. 然后，添加： $ git add readme.txt$ git status# On branch master# Changes to be committed:# (use "git reset HEAD &lt;file&gt;..." to unstage)## modified: readme.txt# 然后，再修改readme.txt： $ cat readme.txt Git is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files. 提交： $ git commit -m "git tracks changes"[master d4f25b6] git tracks changes 1 file changed, 1 insertion(+) 提交后，再看看状态： $ git status# On branch master# Changes not staged for commit:# (use "git add &lt;file&gt;..." to update what will be committed)# (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)## modified: readme.txt#no changes added to commit (use "git add" and/or "git commit -a") 咦，怎么第二次的修改没有被提交？ 别激动，我们回顾一下操作过程： 第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git commit 你看，我们前面讲了，Git管理的是修改，当你用git add命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，git commit只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。 提交后，用git diff HEAD -- readme.txt命令可以查看工作区和版本库里面最新版本的区别： $ git diff HEAD -- readme.txt diff --git a/readme.txt b/readme.txtindex 76d770f..a9c5755 100644--- a/readme.txt+++ b/readme.txt@@ -1,4 +1,4 @@ Git is a distributed version control system. Git is free software distributed under the GPL. Git has a mutable index called stage.-Git tracks changes.+Git tracks changes of files. 可见，第二次修改确实没有被提交。 那怎么提交第二次修改呢？你可以继续git add再git commit，也可以别着急提交第一次修改，先git add第二次修改，再git commit，就相当于把两次修改合并后一块提交了： 第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git add -&gt; git commit 好，现在，把第二次修改提交了，然后开始小结。 小结 现在，你又理解了Git是如何跟踪修改的，每次修改，如果不add到暂存区，那就不会加入到commit中。 撤销修改自然，你是不会犯错的。不过现在是凌晨两点，你正在赶一份工作报告，你在readme.txt中添加了一行： $ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.My stupid boss still prefers SVN. 在你准备提交前，一杯咖啡起了作用，你猛然发现了“stupid boss”可能会让你丢掉这个月的奖金！ 既然错误发现得很及时，就可以很容易地纠正它。你可以删掉最后一行，手动把文件恢复到上一个版本的状态。如果用git status查看一下： $ git status# On branch master# Changes not staged for commit:# (use "git add &lt;file&gt;..." to update what will be committed)# (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)## modified: readme.txt#no changes added to commit (use "git add" and/or "git commit -a") 你可以发现，Git会告诉你，git checkout -- file可以丢弃工作区的修改： $ git checkout -- readme.txt 命令git checkout -- readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况： 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 总之，就是让这个文件回到最近一次git commit或git add时的状态。 现在，看看readme.txt的文件内容： $ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files. 文件内容果然复原了。 git checkout -- file命令中的--很重要，没有--，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到git checkout命令。 现在假定是凌晨3点，你不但写了一些胡话，还git add到暂存区了： $ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.My stupid boss still prefers SVN.$ git add readme.txt 庆幸的是，在commit之前，你发现了这个问题。用git status查看一下，修改只是添加到了暂存区，还没有提交： $ git status# On branch master# Changes to be committed:# (use "git reset HEAD &lt;file&gt;..." to unstage)## modified: readme.txt# Git同样告诉我们，用命令git reset HEAD file可以把暂存区的修改撤销掉（unstage），重新放回工作区： $ git reset HEAD readme.txtUnstaged changes after reset:M readme.txt git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。 再用git status查看一下，现在暂存区是干净的，工作区有修改： $ git status# On branch master# Changes not staged for commit:# (use "git add &lt;file&gt;..." to update what will be committed)# (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)## modified: readme.txt#no changes added to commit (use "git add" and/or "git commit -a") 还记得如何丢弃工作区的修改吗？ $ git checkout -- readme.txt$ git status# On branch masternothing to commit (working directory clean) 整个世界终于清静了！ 现在，假设你不但改错了东西，还从暂存区提交到了版本库，怎么办呢？还记得版本回退一节吗？可以回退到上一个版本。不过，这是有条件的，就是你还没有把自己的本地版本库推送到远程。还记得Git是分布式版本控制系统吗？我们后面会讲到远程版本库，一旦你把“stupid boss”提交推送到远程版本库，你就真的惨了…… 小结 又到了小结时间。 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作。 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。 删除文件在Git中，删除也是一个修改操作，我们实战一下，先添加一个新文件test.txt到Git并且提交： $ git add test.txt$ git commit -m "add test.txt"[master 94cdc44] add test.txt 1 file changed, 1 insertion(+) create mode 100644 test.txt 一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了： $ rm test.txt 这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了： $ git status# On branch master# Changes not staged for commit:# (use "git add/rm &lt;file&gt;..." to update what will be committed)# (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)## deleted: test.txt#no changes added to commit (use "git add" and/or "git commit -a") 现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit： $ git rm test.txtrm 'test.txt'$ git commit -m "remove test.txt"[master d17efd8] remove test.txt 1 file changed, 1 deletion(-) delete mode 100644 test.txt 现在，文件就从版本库中被删除了。 另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本： $ git checkout -- test.txt git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。 小结 命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。 远程仓库到目前为止，我们已经掌握了如何在Git仓库里对一个文件进行时光穿梭，你再也不用担心文件备份或者丢失的问题了。 可是有用过集中式版本控制系统SVN的童鞋会站出来说，这些功能在SVN里早就有了，没看出Git有什么特别的地方。 没错，如果只是在一个仓库里管理文件历史，Git和SVN真没啥区别。为了保证你现在所学的Git物超所值，将来绝对不会后悔，同时为了打击已经不幸学了SVN的童鞋，本章开始介绍Git的杀手级功能之一（注意是之一，也就是后面还有之二，之三……）：远程仓库。 Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。怎么分布呢？最早，肯定只有一台机器有一个原始版本库，此后，别的机器可以“克隆”这个原始版本库，而且每台机器的版本库其实都是一样的，并没有主次之分。 你肯定会想，至少需要两台机器才能玩远程库不是？但是我只有一台电脑，怎么玩？ 其实一台电脑上也是可以克隆多个版本库的，只要不在同一个目录下。不过，现实生活中是不会有人这么傻的在一台电脑上搞几个远程库玩，因为一台电脑上搞几个远程库完全没有意义，而且硬盘挂了会导致所有库都挂掉，所以我也不告诉你在一台电脑上怎么克隆多个仓库。 实际情况往往是这样，找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。 完全可以自己搭建一台运行Git的服务器，不过现阶段，为了学Git先搭个服务器绝对是小题大作。好在这个世界上有个叫GitHub的神奇的网站，从名字就可以看出，这个网站就是提供Git仓库托管服务的，所以，只要注册一个GitHub账号，就可以免费获得Git远程仓库。 在继续阅读后续内容前，请自行注册GitHub账号。由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置： 第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key： $ ssh-keygen -t rsa -C "youremail@example.com" 你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。 如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。 第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面： 然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容： 点“Add Key”，你就应该看到已经添加的Key： 为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。 当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。 最后友情提示，在GitHub上免费托管的Git仓库，任何人都可以看到喔（但只有你自己才能改）。所以，不要把敏感信息放进去。 如果你不想让别人看到Git库，有两个办法，一个是交点保护费，让GitHub把公开的仓库变成私有的，这样别人就看不见了（不可读更不可写）。另一个办法是自己动手，搭一个Git服务器，因为是你自己的Git服务器，所以别人也是看不见的。这个方法我们后面会讲到的，相当简单，公司内部开发必备。 确保你拥有一个GitHub账号后，我们就即将开始远程仓库的学习。 小结 “有了远程仓库，妈妈再也不用担心我的硬盘了。”——Git点读机 添加远程库现在的情景是，你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。 首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库： 在Repository name填入learngit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库： 目前，在GitHub上的这个learngit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。 现在，我们根据GitHub的提示，在本地的learngit仓库下运行命令： $ git remote add origin git@github.com:michaelliao/learngit.git 请千万注意，把上面的michaelliao替换成你自己的GitHub账户名，否则，你在本地关联的就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。 添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。 下一步，就可以把本地库的所有内容推送到远程库上： $ git push -u origin masterCounting objects: 19, done.Delta compression using up to 4 threads.Compressing objects: 100% (19/19), done.Writing objects: 100% (19/19), 13.73 KiB, done.Total 23 (delta 6), reused 0 (delta 0)To git@github.com:michaelliao/learngit.git * [new branch] master -&gt; masterBranch master set up to track remote branch master from origin. 把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样： 从现在起，只要本地作了提交，就可以通过命令： $ git push origin master 把本地master分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！ SSH警告当你第一次使用Git的clone或者push命令连接GitHub时，会得到一个警告： The authenticity of host 'github.com (xx.xx.xx.xx)' can't be established.RSA key fingerprint is xx.xx.xx.xx.xx.Are you sure you want to continue connecting (yes/no)? 这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入yes回车即可。 Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了： Warning: Permanently added 'github.com' (RSA) to the list of known hosts. 这个警告只会出现一次，后面的操作就不会有任何警告了。 如果你实在担心有人冒充GitHub服务器，输入yes前可以对照GitHub的RSA Key的指纹信息是否与SSH连接给出的一致。 小结 要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git； 关联后，使用命令git push -u origin master第一次推送master分支的所有内容； 此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改； 分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！ 从远程库克隆上次我们讲了先有本地库，后有远程库的时候，如何关联远程库。 现在，假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。 首先，登陆GitHub，创建一个新的仓库，名字叫gitskills： 我们勾选Initialize this repository with a README，这样GitHub会自动为我们创建一个README.md文件。创建完毕后，可以看到README.md文件： 现在，远程库已经准备好了，下一步是用命令git clone克隆一个本地库： $ git clone git@github.com:michaelliao/gitskills.gitCloning into 'gitskills'...remote: Counting objects: 3, done.remote: Total 3 (delta 0), reused 0 (delta 0)Receiving objects: 100% (3/3), done.$ cd gitskills$ lsREADME.md 注意把Git库的地址换成你自己的，然后进入gitskills目录看看，已经有README.md文件了。 如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。 你也许还注意到，GitHub给出的地址不止一个，还可以用https://github.com/michaelliao/gitskills.git这样的地址。实际上，Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。 使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https。 小结 要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆。 Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。 分支管理分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。 如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，你既学会了Git又学会了SVN！ 分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。 现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。 其他版本控制系统如SVN等都有分支管理，但是用过之后你会发现，这些版本控制系统创建和切换分支比蜗牛还慢，简直让人无法忍受，结果分支功能成了摆设，大家都不去用。 但Git的分支是与众不同的，无论创建、切换和删除分支，Git在1秒钟之内就能完成！无论你的版本库是1个文件还是1万个文件。 创建与合并分支在版本回退里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。 一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点： 每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长： 当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上： 你看，Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！ 不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变： 假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并： 所以Git合并分支也很快！就改改指针，工作区内容也不变！ 合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支： 真是太神奇了，你看得出来有些提交是通过分支完成的吗？ 下面开始实战。 首先，我们创建dev分支，然后切换到dev分支： $ git checkout -b devSwitched to a new branch 'dev' git checkout命令加上-b参数表示创建并切换，相当于以下两条命令： $ git branch dev$ git checkout devSwitched to branch 'dev' 然后，用git branch命令查看当前分支： $ git branch* dev master git branch命令会列出所有分支，当前分支前面会标一个*号。 然后，我们就可以在dev分支上正常提交，比如对readme.txt做个修改，加上一行： Creating a new branch is quick. 然后提交： $ git add readme.txt $ git commit -m "branch test"[dev fec145a] branch test 1 file changed, 1 insertion(+) 现在，dev分支的工作完成，我们就可以切换回master分支： $ git checkout masterSwitched to branch 'master' 切换回master分支后，再查看一个readme.txt文件，刚才添加的内容不见了！因为那个提交是在dev分支上，而master分支此刻的提交点并没有变： 现在，我们把dev分支的工作成果合并到master分支上： $ git merge devUpdating d17efd8..fec145aFast-forward readme.txt | 1 + 1 file changed, 1 insertion(+) git merge命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。 注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。 当然，也不是每次合并都能Fast-forward，我们后面会讲其他方式的合并。 合并完成后，就可以放心地删除dev分支了： $ git branch -d devDeleted branch dev (was fec145a). 删除后，查看branch，就只剩下master分支了： $ git branch* master 因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。 小结 Git鼓励大量使用分支： 查看分支：git branch 创建分支：git branch 切换分支：git checkout 创建+切换分支：git checkout -b 合并某分支到当前分支：git merge 删除分支：git branch -d 解决冲突人生不如意之事十之八九，合并分支往往也不是一帆风顺的。 准备新的feature1分支，继续我们的新分支开发： $ git checkout -b feature1Switched to a new branch 'feature1' 修改readme.txt最后一行，改为： Creating a new branch is quick AND simple. 在feature1分支上提交： $ git add readme.txt $ git commit -m "AND simple"[feature1 75a857c] AND simple 1 file changed, 1 insertion(+), 1 deletion(-) 切换到master分支： $ git checkout masterSwitched to branch 'master'Your branch is ahead of 'origin/master' by 1 commit. Git还会自动提示我们当前master分支比远程的master分支要超前1个提交。 在master分支上把readme.txt文件的最后一行改为： Creating a new branch is quick &amp; simple. 提交： $ git add readme.txt $ git commit -m "&amp; simple"[master 400b400] &amp; simple 1 file changed, 1 insertion(+), 1 deletion(-) 现在，master分支和feature1分支各自都分别有新的提交，变成了这样： 这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看： $ git merge feature1Auto-merging readme.txtCONFLICT (content): Merge conflict in readme.txtAutomatic merge failed; fix conflicts and then commit the result. 果然冲突了！Git告诉我们，readme.txt文件存在冲突，必须手动解决冲突后再提交。git status也可以告诉我们冲突的文件： $ git status# On branch master# Your branch is ahead of 'origin/master' by 2 commits.## Unmerged paths:# (use "git add/rm &lt;file&gt;..." as appropriate to mark resolution)## both modified: readme.txt#no changes added to commit (use "git add" and/or "git commit -a") 我们可以直接查看readme.txt的内容： Git is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADCreating a new branch is quick &amp; simple.=======Creating a new branch is quick AND simple.&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1 Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，我们修改如下后保存： Creating a new branch is quick and simple. 再提交： $ git add readme.txt $ git commit -m "conflict fixed"[master 59bc1cb] conflict fixed 现在，master分支和feature1分支变成了下图所示： 用带参数的git log也可以看到分支的合并情况： $ git log --graph --pretty=oneline --abbrev-commit* 59bc1cb conflict fixed|\| * 75a857c AND simple* | 400b400 &amp; simple|/* fec145a branch test... 最后，删除feature1分支： $ git branch -d feature1Deleted branch feature1 (was 75a857c). 工作完成。 小结 当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。 用git log --graph命令可以看到分支合并图。 分支管理策略通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。 如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。 下面我们实战一下--no-ff方式的git merge： 首先，仍然创建并切换dev分支： $ git checkout -b devSwitched to a new branch 'dev' 修改readme.txt文件，并提交一个新的commit： $ git add readme.txt $ git commit -m "add merge"[dev 6224937] add merge 1 file changed, 1 insertion(+) 现在，我们切换回master： $ git checkout masterSwitched to branch 'master' 准备合并dev分支，请注意--no-ff参数，表示禁用Fast forward： $ git merge --no-ff -m "merge with no-ff" devMerge made by the 'recursive' strategy. readme.txt | 1 + 1 file changed, 1 insertion(+) 因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。 合并后，我们用git log看看分支历史： $ git log --graph --pretty=oneline --abbrev-commit* 7825a50 merge with no-ff|\| * 6224937 add merge|/* 59bc1cb conflict fixed... 可以看到，不使用Fast forward模式，merge后就像这样： 分支策略在实际开发中，我们应该按照几个基本原则进行分支管理： 首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活； 那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本； 你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。 所以，团队合作的分支看起来就像这样： 小结 Git分支十分强大，在团队开发中应该充分应用。 合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。 Bug分支软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。 当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它，但是，等等，当前正在dev上进行的工作还没有提交： $ git status# On branch dev# Changes to be committed:# (use "git reset HEAD &lt;file&gt;..." to unstage)## new file: hello.py## Changes not staged for commit:# (use "git add &lt;file&gt;..." to update what will be committed)# (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)## modified: readme.txt# 并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？ 幸好，Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作： $ git stashSaved working directory and index state WIP on dev: 6224937 add mergeHEAD is now at 6224937 add merge 现在，用git status查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。 首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支： $ git checkout masterSwitched to branch 'master'Your branch is ahead of 'origin/master' by 6 commits.$ git checkout -b issue-101Switched to a new branch 'issue-101' 现在修复bug，需要把“Git is free software …”改为“Git is a free software …”，然后提交： $ git add readme.txt $ git commit -m "fix bug 101"[issue-101 cc17032] fix bug 101 1 file changed, 1 insertion(+), 1 deletion(-) 修复完成后，切换到master分支，并完成合并，最后删除issue-101分支： $ git checkout masterSwitched to branch 'master'Your branch is ahead of 'origin/master' by 2 commits.$ git merge --no-ff -m "merged bug fix 101" issue-101Merge made by the 'recursive' strategy. readme.txt | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-)$ git branch -d issue-101Deleted branch issue-101 (was cc17032). 太棒了，原计划两个小时的bug修复只花了5分钟！现在，是时候接着回到dev分支干活了！ $ git checkout devSwitched to branch 'dev'$ git status# On branch devnothing to commit (working directory clean) 工作区是干净的，刚才的工作现场存到哪去了？用git stash list命令看看： $ git stash liststash@&#123;0&#125;: WIP on dev: 6224937 add merge 工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法： 一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除； 另一种方式是用git stash pop，恢复的同时把stash内容也删了： $ git stash pop# On branch dev# Changes to be committed:# (use "git reset HEAD &lt;file&gt;..." to unstage)## new file: hello.py## Changes not staged for commit:# (use "git add &lt;file&gt;..." to update what will be committed)# (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)## modified: readme.txt#Dropped refs/stash@&#123;0&#125; (f624f8e5f082f2df2bed8a4e09c12fd2943bdd40) 再用git stash list查看，就看不到任何stash内容了： $ git stash list 你可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令： $ git stash apply stash@&#123;0&#125; 小结 修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除； 当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。 Feature分支软件开发中，总有无穷无尽的新的功能要不断添加进来。 添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。 现在，你终于接到了一个新任务：开发代号为Vulcan的新功能，该功能计划用于下一代星际飞船。 于是准备开发： $ git checkout -b feature-vulcanSwitched to a new branch 'feature-vulcan' 5分钟后，开发完毕： $ git add vulcan.py$ git status# On branch feature-vulcan# Changes to be committed:# (use "git reset HEAD &lt;file&gt;..." to unstage)## new file: vulcan.py#$ git commit -m "add feature vulcan"[feature-vulcan 756d4af] add feature vulcan 1 file changed, 2 insertions(+) create mode 100644 vulcan.py 切回dev，准备合并： $ git checkout dev 一切顺利的话，feature分支和bug分支是类似的，合并，然后删除。 但是， 就在此时，接到上级命令，因经费不足，新功能必须取消！ 虽然白干了，但是这个分支还是必须就地销毁： $ git branch -d feature-vulcanerror: The branch 'feature-vulcan' is not fully merged.If you are sure you want to delete it, run 'git branch -D feature-vulcan'. 销毁失败。Git友情提醒，feature-vulcan分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用命令git branch -D feature-vulcan。 现在我们强行删除： $ git branch -D feature-vulcanDeleted branch feature-vulcan (was 756d4af). 终于删除成功！ 小结 开发一个新feature，最好新建一个分支； 如果要丢弃一个没有被合并过的分支，可以通过git branch -D强行删除。 多人协作当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。 要查看远程库的信息，用git remote： $ git remoteorigin 或者，用git remote -v显示更详细的信息： $ git remote -vorigin git@github.com:michaelliao/learngit.git (fetch)origin git@github.com:michaelliao/learngit.git (push) 上面显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。 推送分支推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上： $ git push origin master 如果要推送其他分支，比如dev，就改成： $ git push origin dev 但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？ master分支是主分支，因此要时刻与远程同步； dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步； bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug； feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。 总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！ 抓取分支多人协作时，大家都会往master和dev分支上推送各自的修改。 现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆： $ git clone git@github.com:michaelliao/learngit.gitCloning into 'learngit'...remote: Counting objects: 46, done.remote: Compressing objects: 100% (26/26), done.remote: Total 46 (delta 16), reused 45 (delta 15)Receiving objects: 100% (46/46), 15.69 KiB | 6 KiB/s, done.Resolving deltas: 100% (16/16), done. 当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的master分支。不信可以用git branch命令看看： $ git branch* master 现在，你的小伙伴要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支： $ git checkout -b dev origin/dev 现在，他就可以在dev上继续修改，然后，时不时地把dev分支push到远程： $ git commit -m "add /usr/bin/env"[dev 291bea8] add /usr/bin/env 1 file changed, 1 insertion(+)$ git push origin devCounting objects: 5, done.Delta compression using up to 4 threads.Compressing objects: 100% (2/2), done.Writing objects: 100% (3/3), 349 bytes, done.Total 3 (delta 0), reused 0 (delta 0)To git@github.com:michaelliao/learngit.git fc38031..291bea8 dev -&gt; dev 你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送： $ git add hello.py $ git commit -m "add coding: utf-8"[dev bd6ae48] add coding: utf-8 1 file changed, 1 insertion(+)$ git push origin devTo git@github.com:michaelliao/learngit.git ! [rejected] dev -&gt; dev (non-fast-forward)error: failed to push some refs to 'git@github.com:michaelliao/learngit.git'hint: Updates were rejected because the tip of your current branch is behindhint: its remote counterpart. Merge the remote changes (e.g. 'git pull')hint: before pushing again.hint: See the 'Note about fast-forwards' in 'git push --help' for details. 推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送： $ git pullremote: Counting objects: 5, done.remote: Compressing objects: 100% (2/2), done.remote: Total 3 (delta 0), reused 3 (delta 0)Unpacking objects: 100% (3/3), done.From github.com:michaelliao/learngit fc38031..291bea8 dev -&gt; origin/devThere is no tracking information for the current branch.Please specify which branch you want to merge with.See git-pull(1) for details git pull &lt;remote&gt; &lt;branch&gt;If you wish to set tracking information for this branch you can do so with: git branch --set-upstream dev origin/&lt;branch&gt; git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接： $ git branch --set-upstream dev origin/devBranch dev set up to track remote branch dev from origin. 再pull： $ git pullAuto-merging hello.pyCONFLICT (content): Merge conflict in hello.pyAutomatic merge failed; fix conflicts and then commit the result. 这回git pull成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样。解决后，提交，再push： $ git commit -m "merge &amp; fix hello.py"[dev adca45d] merge &amp; fix hello.py$ git push origin devCounting objects: 10, done.Delta compression using up to 4 threads.Compressing objects: 100% (5/5), done.Writing objects: 100% (6/6), 747 bytes, done.Total 6 (delta 0), reused 0 (delta 0)To git@github.com:michaelliao/learngit.git 291bea8..adca45d dev -&gt; dev 因此，多人协作的工作模式通常是这样： 首先，可以试图用git push origin branch-name推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！ 如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream branch-name origin/branch-name。 这就是多人协作的工作模式，一旦熟悉了，就非常简单。 小结 查看远程库信息，使用git remote -v； 本地新建的分支如果不推送到远程，对其他人就是不可见的； 从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交； 在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致； 建立本地分支和远程分支的关联，使用git branch --set-upstream branch-name origin/branch-name； 从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。 标签管理发布一个版本时，我们通常先在版本库中打一个标签，这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。 Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。 创建标签在Git中打标签非常简单，首先，切换到需要打标签的分支上： $ git branch* dev master$ git checkout masterSwitched to branch 'master' 然后，敲命令git tag就可以打一个新标签： $ git tag v1.0 可以用命令git tag查看所有标签： $ git tagv1.0 默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？ 方法是找到历史提交的commit id，然后打上就可以了： $ git log --pretty=oneline --abbrev-commit6a5819e merged bug fix 101cc17032 fix bug 1017825a50 merge with no-ff6224937 add merge59bc1cb conflict fixed400b400 &amp; simple75a857c AND simplefec145a branch testd17efd8 remove test.txt... 比方说要对add merge这次提交打标签，它对应的commit id是6224937，敲入命令： $ git tag v0.9 6224937 再用命令git tag查看标签： $ git tagv0.9v1.0 注意，标签不是按时间顺序列出，而是按字母排序的。可以用git show查看标签信息： $ git show v0.9commit 622493706ab447b6bb37e4e2a2f276a20fed2ab4Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Thu Aug 22 11:22:08 2013 +0800 add merge... 可以看到，v0.9确实打在add merge这次提交上。 还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字： $ git tag -a v0.1 -m "version 0.1 released" 3628164 用命令git show可以看到说明文字： $ git show v0.1tag v0.1Tagger: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Mon Aug 26 07:28:11 2013 +0800version 0.1 releasedcommit 3628164fb26d48395383f8f31179f24e0882e1e0Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Tue Aug 20 15:11:49 2013 +0800 append GPL 还可以通过-s用私钥签名一个标签： $ git tag -s v0.2 -m "signed version 0.2 released" fec145a 签名采用PGP签名，因此，必须首先安装gpg（GnuPG），如果没有找到gpg，或者没有gpg密钥对，就会报错： gpg: signing failed: secret key not availableerror: gpg failed to sign the dataerror: unable to sign the tag 如果报错，请参考GnuPG帮助文档配置Key。 用命令git show可以看到PGP签名信息： $ git show v0.2tag v0.2Tagger: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Mon Aug 26 07:28:33 2013 +0800signed version 0.2 released-----BEGIN PGP SIGNATURE-----Version: GnuPG v1.4.12 (Darwin)iQEcBAABAgAGBQJSGpMhAAoJEPUxHyDAhBpT4QQIAKeHfR3bo...-----END PGP SIGNATURE-----commit fec145accd63cdc9ed95a2f557ea0658a2a6537fAuthor: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Thu Aug 22 10:37:30 2013 +0800 branch test 用PGP签名的标签是不可伪造的，因为可以验证PGP签名。验证签名的方法比较复杂，这里就不介绍了。 小结 命令git tag用于新建一个标签，默认为HEAD，也可以指定一个commit id； git tag -a -m &quot;blablabla...&quot;可以指定标签信息； git tag -s -m &quot;blablabla...&quot;可以用PGP签名标签； 命令git tag可以查看所有标签。 操作标签如果标签打错了，也可以删除： $ git tag -d v0.1Deleted tag 'v0.1' (was e078af9) 因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。 如果要推送某个标签到远程，使用命令git push origin： $ git push origin v1.0Total 0 (delta 0), reused 0 (delta 0)To git@github.com:michaelliao/learngit.git * [new tag] v1.0 -&gt; v1.0 或者，一次性推送全部尚未推送到远程的本地标签： $ git push origin --tagsCounting objects: 1, done.Writing objects: 100% (1/1), 554 bytes, done.Total 1 (delta 0), reused 0 (delta 0)To git@github.com:michaelliao/learngit.git * [new tag] v0.2 -&gt; v0.2 * [new tag] v0.9 -&gt; v0.9 如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除： $ git tag -d v0.9Deleted tag 'v0.9' (was 6224937) 然后，从远程删除。删除命令也是push，但是格式如下： $ git push origin :refs/tags/v0.9To git@github.com:michaelliao/learngit.git - [deleted] v0.9 要看看是否真的从远程库删除了标签，可以登陆GitHub查看。 小结 命令git push origin可以推送一个本地标签； 命令git push origin --tags可以推送全部未推送过的本地标签； 命令git tag -d可以删除一个本地标签； 命令git push origin :refs/tags/可以删除一个远程标签。 使用GitHub我们一直用GitHub作为免费的远程仓库，如果是个人的开源项目，放到GitHub上是完全没有问题的。其实GitHub还是一个开源协作社区，通过GitHub，既可以让别人参与你的开源项目，也可以参与别人的开源项目。 在GitHub出现以前，开源项目开源容易，但让广大人民群众参与进来比较困难，因为要参与，就要提交代码，而给每个想提交代码的群众都开一个账号那是不现实的，因此，群众也仅限于报个bug，即使能改掉bug，也只能把diff文件用邮件发过去，很不方便。 但是在GitHub上，利用Git极其强大的克隆和分支功能，广大人民群众真正可以第一次自由参与各种开源项目了。 如何参与一个开源项目呢？比如人气极高的bootstrap项目，这是一个非常强大的CSS框架，你可以访问它的项目主页https://github.com/twbs/bootstrap，点“Fork”就在自己的账号下克隆了一个bootstrap仓库，然后，从自己的账号下clone： git clone git@github.com:michaelliao/bootstrap.git 一定要从自己的账号下clone仓库，这样你才能推送修改。如果从bootstrap的作者的仓库地址git@github.com:twbs/bootstrap.git克隆，因为没有权限，你将不能推送修改。 Bootstrap的官方仓库twbs/bootstrap、你在GitHub上克隆的仓库my/bootstrap，以及你自己克隆到本地电脑的仓库，他们的关系就像下图显示的那样： 如果你想修复bootstrap的一个bug，或者新增一个功能，立刻就可以开始干活，干完后，往自己的仓库推送。 如果你希望bootstrap的官方库能接受你的修改，你就可以在GitHub上发起一个pull request。当然，对方是否接受你的pull request就不一定了。 如果你没能力修改bootstrap，但又想要试一把pull request，那就Fork一下我的仓库：https://github.com/michaelliao/learngit，创建一个your-github-id.txt的文本文件，写点自己学习Git的心得，然后推送一个pull request给我，我会视心情而定是否接受。 小结 在GitHub上，可以任意Fork开源仓库； 自己拥有Fork后的仓库的读写权限； 可以推送pull request给官方仓库来贡献代码。 自定义Git在安装Git一节中，我们已经配置了user.name和user.email，实际上，Git还有很多可配置项。 比如，让Git显示颜色，会让命令输出看起来更醒目： $ git config --global color.ui true 这样，Git会适当地显示不同的颜色，比如git status命令： 文件名就会标上颜色。 我们在后面还会介绍如何更好地配置Git，以便让你的工作更高效。 忽略特殊文件有些时候，你必须把某些文件放到Git工作目录中，但又不能提交它们，比如保存了数据库密码的配置文件啦，等等，每次git status都会显示Untracked files ...，有强迫症的童鞋心里肯定不爽。 好在Git考虑到了大家的感受，这个问题解决起来也很简单，在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。 不需要从头写.gitignore文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览：https://github.com/github/gitignore 忽略文件的原则是： 忽略操作系统自动生成的文件，比如缩略图等； 忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件； 忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。 举个例子： 假设你在Windows下进行Python开发，Windows会自动在有图片的目录下生成隐藏的缩略图文件，如果有自定义目录，目录下就会有Desktop.ini文件，因此你需要忽略Windows自动生成的垃圾文件： # Windows:Thumbs.dbehthumbs.dbDesktop.ini 然后，继续忽略Python编译产生的.pyc、.pyo、dist等文件或目录： # Python:*.py[cod]*.so*.egg*.egg-infodistbuild 加上你自己定义的文件，最终得到一个完整的.gitignore文件，内容如下： # Windows:Thumbs.dbehthumbs.dbDesktop.ini# Python:*.py[cod]*.so*.egg*.egg-infodistbuild# My configurations:db.inideploy_key_rsa 最后一步就是把.gitignore也提交到Git，就完成了！当然检验.gitignore的标准是git status命令是不是说working directory clean。 使用Windows的童鞋注意了，如果你在资源管理器里新建一个.gitignore文件，它会非常弱智地提示你必须输入文件名，但是在文本编辑器里“保存”或者“另存为”就可以把文件保存为.gitignore了。 小结 忽略某些文件时，需要编写.gitignore； .gitignore文件本身要放到版本库里，并且可以对.gitignore做版本管理！ 配置别名有没有经常敲错命令？比如git status？status这个单词真心不好记。 如果敲git st就表示git status那就简单多了，当然这种偷懒的办法我们是极力赞成的。 我们只需要敲一行命令，告诉Git，以后st就表示status： $ git config --global alias.st status 好了，现在敲git st看看效果。 当然还有别的命令可以简写，很多人都用co表示checkout，ci表示commit，br表示branch： $ git config --global alias.co checkout$ git config --global alias.ci commit$ git config --global alias.br branch 以后提交就可以简写成： $ git ci -m "bala bala bala..." --global参数是全局参数，也就是这些命令在这台电脑的所有Git仓库下都有用。 在撤销修改一节中，我们知道，命令git reset HEAD file可以把暂存区的修改撤销掉（unstage），重新放回工作区。既然是一个unstage操作，就可以配置一个unstage别名： $ git config --global alias.unstage 'reset HEAD' 当你敲入命令： $ git unstage test.py 实际上Git执行的是： $ git reset HEAD test.py 配置一个git last，让其显示最后一次提交信息： $ git config --global alias.last 'log -1' 这样，用git last就能显示最近一次的提交： $ git lastcommit adca45d317e6d8a4b23f9811c3d7b7f0f180bfe2Merge: bd6ae48 291bea8Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Thu Aug 22 22:49:22 2013 +0800 merge &amp; fix hello.py 甚至还有人丧心病狂地把lg配置成了： git config --global alias.lg "log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit" 来看看git lg的效果： 为什么不早点告诉我？别激动，咱不是为了多记几个英文单词嘛！ 配置文件配置Git的时候，加上--global是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。 配置文件放哪了？每个仓库的Git配置文件都放在.git/config文件中： $ cat .git/config [core] repositoryformatversion = 0 filemode = true bare = false logallrefupdates = true ignorecase = true precomposeunicode = true[remote "origin"] url = git@github.com:michaelliao/learngit.git fetch = +refs/heads/*:refs/remotes/origin/*[branch "master"] remote = origin merge = refs/heads/master[alias] last = log -1 别名就在[alias]后面，要删除别名，直接把对应的行删掉即可。 而当前用户的Git配置文件放在用户主目录下的一个隐藏文件.gitconfig中： $ cat .gitconfig[alias] co = checkout ci = commit br = branch st = status[user] name = Your Name email = your@email.com 配置别名也可以直接修改这个文件，如果改错了，可以删掉文件重新通过命令配置。 小结 给Git配置好别名，就可以输入命令时偷个懒。我们鼓励偷懒。 搭建Git服务器在远程仓库一节中，我们讲了远程仓库实际上和本地仓库没啥不同，纯粹为了7x24小时开机并交换大家的修改。 GitHub就是一个免费托管开源代码的远程仓库。但是对于某些视源代码如生命的商业公司来说，既不想公开源代码，又舍不得给GitHub交保护费，那就只能自己搭建一台Git服务器作为私有仓库使用。 搭建Git服务器需要准备一台运行Linux的机器，强烈推荐用Ubuntu或Debian，这样，通过几条简单的apt命令就可以完成安装。 假设你已经有sudo权限的用户账号，下面，正式开始安装。 第一步，安装git： $ sudo apt-get install git 第二步，创建一个git用户，用来运行git服务： $ sudo adduser git 第三步，创建证书登录： 收集所有需要登录的用户的公钥，就是他们自己的id_rsa.pub文件，把所有公钥导入到/home/git/.ssh/authorized_keys文件里，一行一个。 第四步，初始化Git仓库： 先选定一个目录作为Git仓库，假定是/srv/sample.git，在/srv目录下输入命令： $ sudo git init --bare sample.git Git就会创建一个裸仓库，裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以.git结尾。然后，把owner改为git： $ sudo chown -R git:git sample.git 第五步，禁用shell登录： 出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑/etc/passwd文件完成。找到类似下面的一行： git:x:1001:1001:,,,:/home/git:/bin/bash 改为： git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell 这样，git用户可以正常通过ssh使用git，但无法登录shell，因为我们为git用户指定的git-shell每次一登录就自动退出。 第六步，克隆远程仓库： 现在，可以通过git clone命令克隆远程仓库了，在各自的电脑上运行： $ git clone git@server:/srv/sample.gitCloning into 'sample'...warning: You appear to have cloned an empty repository. 剩下的推送就简单了。 管理公钥如果团队很小，把每个人的公钥收集起来放到服务器的/home/git/.ssh/authorized_keys文件里就是可行的。如果团队有几百号人，就没法这么玩了，这时，可以用Gitosis来管理公钥。 这里我们不介绍怎么玩Gitosis了，几百号人的团队基本都在500强了，相信找个高水平的Linux管理员问题不大。 管理权限有很多不但视源代码如生命，而且视员工为窃贼的公司，会在版本控制系统里设置一套完善的权限控制，每个人是否有读写权限会精确到每个分支甚至每个目录下。因为Git是为Linux源代码托管而开发的，所以Git也继承了开源社区的精神，不支持权限控制。不过，因为Git支持钩子（hook），所以，可以在服务器端编写一系列脚本来控制提交等操作，达到权限控制的目的。Gitolite就是这个工具。 这里我们也不介绍Gitolite了，不要把有限的生命浪费到权限斗争中。 小结 搭建Git服务器非常简单，通常10分钟即可完成； 要方便管理公钥，用Gitosis； 要像SVN那样变态地控制权限，用Gitolite。 期末总结终于到了期末总结的时刻了！ 经过几天的学习，相信你对Git已经初步掌握。一开始，可能觉得Git上手比较困难，尤其是已经熟悉SVN的童鞋，没关系，多操练几次，就会越用越顺手。 Git虽然极其强大，命令繁多，但常用的就那么十来个，掌握好这十几个常用命令，你已经可以得心应手地使用Git了。 友情附赠国外网友制作的Git Cheat Sheet，建议打印出来备用： Git Cheat Sheet 现在告诉你Git的官方网站：http://git-scm.com，英文自我感觉不错的童鞋，可以经常去官网看看。什么，打不开网站？相信我，我给出的绝对是官网地址，而且，Git官网决没有那么容易宕机，可能是你的人品问题，赶紧面壁思过，好好想想原因。 如果你学了Git后，工作效率大增，有更多的空闲时间健身看电影，那我的教学目标就达到了。 谢谢观看！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SSH-Key 与多组公钥/私钥的配置]]></title>
      <url>%2F2016%2F02%2F08%2F2016-02-08-SSH-Key%2F</url>
      <content type="text"><![CDATA[再也不用输入 SSH 密码了 SSH-Key 本质上是公钥与私钥，经常在 Git 服务器上应用，主流 Git 托管平台 Github 和 Coding 等也都支持 SSH-Key。 公钥与私钥公钥（Public Key）与私钥（Private Key）是通过一种算法得到的一个密钥对（即一个公钥和一个私钥）。公钥通常用于加密会话密钥、验证数字签名，或加密可以用相应的私钥解密的数据。通过这种算法得到的密钥对能保证在世界范围内是唯一的。使用这个密钥对的时候，如果用其中一个密钥加密一段数据，必须用另一个密钥解密。比如用公钥加密数据就必须用私钥解密，如果用私钥加密也必须用公钥解密，否则解密将不会成功。 想实现本地免密码登录服务器，应在本地生成公钥私钥，公钥配置到服务器即可。 生成输入 ssh-keygen -t rsa -b 4096 -C "YOUR_STAMP" YOUR_STAMP 为任意标记，通常为 Email，下文以 one@joehill.me 为例。 # Creates a new ssh key, using the provided email as a label# Generating public/private rsa key pair.Enter file in which to save the key (/Users/you/.ssh/id_rsa): [Press enter] // 推荐使用默认地址,如果使用非默认地址可能需要配置 .ssh/config 成功之后 Your identification has been saved in /Users/you/.ssh/id_rsa.# Your public key has been saved in /Users/you/.ssh/id_rsa.pub.# The key fingerprint is:# 01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db one@joehill.me 在 ~/.ssh/ 下打开 id_rsa.pub 文件，内容填入 Git 托管平台对应页面即可。以 Github 为例，如果配置成功，如下显示 ssh -T git@github.comWelcome to GitHub, you name! 多组公钥私钥公钥私钥不仅应用在 Git 托管平台上，如果只有一组私钥密钥一旦被捕获，所有的远程服务器都会面临安全问题。多个平台或者服务器对应多组私钥。 默认生成的密钥名称为 id_rsa，下面以生成 github_rsa 和 coding_rsa 两组密钥为例。 ssh-keygen -t rsa -b 4096 ~/.ssh/github_rsa -C "Joe-G@github.com"ssh-keygen -t rsa -b 4096 ~/.ssh/coding_rsa -C "Joe_Hill@coding.net" 当有多个密钥需要管理时候，访问不同的服务器使用不同的密钥，需要配置 ~/.ssh/config Host github.com IdentityFile ~/.ssh/github_rsa User gitHost git.coding.net IdentityFile ~/.ssh/coding_rsa User git 配置后访问 Github 会验证 github_rsa 的私钥，访问 Coding 会验证 coding_rsa 的私钥。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[浅拷贝深拷贝以及 Hash/Equal]]></title>
      <url>%2F2016%2F01%2F05%2F2016-01-05-Copy-Hash-Equal%2F</url>
      <content type="text"><![CDATA[为什么要重载 Hash/Equal 深拷贝与浅拷贝首先，只有遵守 NSCopying 协议的类才能发送 copy 消息。同理，遵守了 NSMutableCopying 协议的类才能发送 mutableCopy 消息。大部分 Foundation 中的类都遵守 NSCopying 协议，但是 NSObject 的子类，也就是我们自定义的类并未遵守 NSCopying 协议。 浅拷贝，又称为指针拷贝，并不会分配新的内存空间，新的指针和原指针指向同一地址。 深拷贝，又称对象拷贝，会分配新的内存空间，新指针和原指针指向不同的内存地址，但是存储的内容相同。 依照深拷贝浅拷贝的特性，浅拷贝多用于添加引用，达到操作新对象，则所有指向同步发生变化的目的；反之深拷贝是隔离原对象和新对象，各自操作互不干扰。 Foundation 中非容器对象的 Copy copy mutableCopy NSString 浅拷贝 深拷贝 NSMutableString 深拷贝 深拷贝 由表格可见，除了不可变对象 NSString 的不可变副本是浅拷贝以外，其他均为深拷贝。由于对象本身为不可变对象，所以在 copy 不可变副本的时候才用了指针复制，无必要新分配空间做深拷贝。 Foundation 中容器对象的 Copy copy mutableCopy NSArray 浅拷贝 深拷贝 NSMutableArray 深拷贝 深拷贝 Object in NSArray 浅拷贝 浅拷贝 Object in NSMutableArray 浅拷贝 浅拷贝 除了不可变对象 NSArray 的不可变副本为浅拷贝以外，其他容器对象均为深拷贝。需要指出的是，容器内的对象均为浅拷贝，这就意味着，新容器的内部的对象改变，原容器内部的对象会同步改变。 如果要实现容器和内部对象的深拷贝，需要遵循 NSCoding 协议，先将对象 archive 再 unarchive。 NSArray *array = @[@1, @2];NSData *data = [NSKeyedArchiver archivedDataWithRootObject:array];NSArray *newArray = [NSUnarchiver unarchiveObjectWithData:data]; 此时 newArray 无论是容器本身还是容器内部对象都和原来的 array 无关联。 自定义对象的 Copy自定义对象继承自 NSObject，需要自己实现 NSCopying 协议下的 copyWithZone 方法。 Person.h #import &lt;Foundation/Foundation.h&gt;@interface Person : NSObject&lt;NSCopying&gt;+ (Person *)personWithName:(NSString *)name age:(NSString *)age;@end Person.m #import "Person.h"@interface Person ()@property (nonatomic, strong) NSString *name;@property (nonatomic, strong) NSString *age;@end@implementation Person- (Person *)initWithName:(NSString *)name age:(NSString *)age &#123; if (self = [super init]) &#123; self.name = name; self.age = age; &#125; return self;&#125;+ (Person *)personWithName:(NSString *)name age:(NSString *)age &#123; return [[self alloc] initWithName:name age:age];&#125;- (Person *)copyWithZone:(NSZone *)zone &#123; Person *person = [[Person allocWithZone:zone] init]; person.name = [self.name copyWithZone:zone]; person.age = [self.age copyWithZone:zone]; return person;&#125;@end Hash/EqualEqualNSObject 类中的 equal 方法的判断，是包括内存地址的。换句话说，NSObject 若想判断两个对象相等，那这两个对象的地址必须相同。 但实际编码中，我们常常设计一个对象，其各项属性相同， 我们就认为他们 equal，要达到这个目的，我们就要重载 equal 方法。于是我们在上述的 Person 对象中重载如下方法： Person.m - (BOOL)isEqual:(Person *)other &#123; BOOL isMyClass = [other isKindOfClass:self.class]; BOOL isEqualToName = [other.name isEqualToString:self.name]; BOOL isEqualToAge = [other.age isEqualToString:other.age]; if (isMyClass &amp;&amp; isEqualToName &amp;&amp; isEqualToAge) &#123; return YES; &#125; return NO;&#125; main.m #import &lt;Foundation/Foundation.h&gt;#import "Person.h"int main(int argc, const char *argv[]) &#123; @autoreleasepool &#123; Person *person1 = [Person personWithName:@"Joe" age:@"32"]; Person *person2 = [Person personWithName:@"Joe" age:@"32"]; NSLog(@"isEqual-----%zd", [person1 isEqual:person2]); &#125; return 0;&#125; 控制台打印结果为 isEqual-----1 证明确实完成了属性相同，就判断两个对象 equal 的目的。 Hash任何 Objective-C 都有 hash 方法，该方法返回一个 NSUInteger，是该对象的 hashCode。 -(NSUInteger)hash &#123; return (NSUInteger)self&gt;&gt;4;&#125; 上述是 Cocotron 的 hashCode 的计算方式，简单通过移位实现。右移4位，左边补0。因为对象大多存于堆中，地址相差4位应该很正常，所以不同对象可能会有相同的 hashCode。当对象存入集合(NSSet, NSDictionary)中，他们的 hashCode 会作为 key 来决定放入哪个集合中。 存储表 hashCode subCollection code1 value1,value2,value3,value4 code2 value5,value6 code3 value7 code4 value8,value9,value10 集合的内部是一个 hash 表，由于不同对象的 hashCode 可能相同，所以同一个 hashCode 对象的将会是一个 subCollection 的集合。如果要删除或者比较集合内元素，它首先根据 hashCode 找到子集合，然后跟子集合的每个元素比较。 集合内部的查找策略是，先比较 hashCode，如果 hashCode 不同，则直接判定两个对象不同；如果 hashCode 相同，则落到同一个 subCollection 中，再调用 equal 方法具体判断对象是否相同。所以，如果两个对象相同，则 hashCode 一定相同；反之，hashCode 相同的两个对象，并不一定是相同的对象。 如果所有对象的 hashCode 都相同，那么每次比较都会调用 equal 方法，整个查询效率会变得很低。 集合中自定义对象的存取本节中集合对象选定为 NSDictionary。Hash 这一节中，我们得知了集合内部实际是一个 HashTable。那自定义对象，按照新逻辑重载 equal 方法之后，在集合中的存取应该如何？ 参考 Cocotron 源码，NSDictionary 使用 NSMapTable 实现的。 @interface NSMapTable : NSObject &#123; NSMapTableKeyCallBacks *keyCallBacks; NSMapTableValueCallBacks *valueCallBacks; NSUInteger count; NSUInteger nBuckets; struct _NSMapNode * *buckets;&#125; 上面是NSMtabtable真正的描述，可以看出来NSMapTable是一个哈希＋链表的数据结构，因此在 NSMapTable 中插入或者删除一对对象时 为对key进行hash得到bucket的位置 遍历该bucket后面冲突的value，通过链表连接起来。 由于一对键值存入字典中之后，key 是不能随意改变的，这样会造成 value 的丢失。所以一个自定义对象作为 key 存入 NSDictionary，必定要深拷贝。正是为了实现这一目的，则 key 必须遵守 NSCopying 协议。 main.m #import &lt;Foundation/Foundation.h&gt;#import "Person.h"int main(int argc, const char *argv[]) &#123; @autoreleasepool &#123; Person *person1 = [Person personWithName:@"Joe" age:@"32"]; Person *person2 = [Person personWithName:@"Joe" age:@"32"]; Person *person3 = [Person personWithName:@"Joe" age:@"33"]; NSMutableDictionary *dict = [[NSMutableDictionary alloc] init]; [dict setObject:@"1" forKey:person1]; [dict setObject:@"2" forKey:person2]; [dict setObject:@"3" forKey:person3]; NSLog(@"person1----%@", [dict objectForKey:person1]); NSLog(@"person2----%@", [dict objectForKey:person2]); NSLog(@"person3----%@", [dict objectForKey:person3]); NSLog(@"dict count: %ld", dict.count); &#125; return 0;&#125; 由于我们重载了 equal 方法，person1 和 person2 应该是相同对象，理论上 dict 的 count 应该是 2。 事实上打印结果是随机的，dict 内部可能会有2或3组键值对。Person 实例化对象取出的值也是不尽相同。这是因为，在对象存入 key 时，每次都要进行 hash/equal 验证，如果为相同对象，则不增加键值对数量，直接覆盖之前 key 的 value。我们重载了 equal 方法，但是 person1 和 person2 的 hashCode 是不同的，则他们直接会被判定为不同的对象，person2 直接作为新的 key 存入了 dict。 在取 key 的时候，依旧要执行 hash/equal ，由于存入 dict 中的副本是深拷贝，那副本的 hashCode 和原对象也是不同的，会判定要查找的对象在 key 中不存在，造成了能存不能查的情况。 这就是我们为什么重载了 equal 就必须还要重载 hash 的根本原因。 重载 hash 要保证，其 hash 算法只跟成员变量相关，即 name 和 age；同时要保证其深拷贝副本的 hashCode 与 原对象相同。 Person.m - (NSUInteger)hash &#123; return [self.name hash] ^ [self.age hash];&#125; 切记不能全部返回相同的 hashCode，这样会每次都调用 equal，效率很差。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[禅与Objective-C编程艺术-3]]></title>
      <url>%2F2015%2F11%2F25%2F2015-11-25-Zen-OC-Art-3%2F</url>
      <content type="text"><![CDATA[编程和「禅」有关系吗?Zen and the Art of the Objective-C Craftsmanship译文兼笔记本章包含规范：Categories、Protocols、NSNotification、代码美化和代码组织 Categories虽然很难看，但是 categories 通常会以小写前缀和下划线开头，比如-(id)zoc_myCategoryMethod。这种写法也是 苹果推荐的. 这是非常必要的因为如果在一个对象的扩展 category 方法或者其他 category 的实现中用了相同的方法名，会导致不可预期的后果。实际上，最终被调用的将会是最后被实现的方法。 这种情况下你想保证没有任何方法的实现被你自己的 category 覆盖的话，你可以把环境变量 OBJC_PRINT_REPLACED_METHODS设定为YES，这样会在控制台打印出来被覆盖掉的方法名。 现在 LLVM 5.1不会为此有任何警告或者错误提示，所以要小心不要在 categories 中重载方法。 在 category 名之前加前缀是一个好习惯。 例如: @interface NSDate (ZOCTimeExtensions)- (NSString *)zoc_timeAgoShort;@end 不要这样: @interface NSDate (ZOCTimeExtensions)- (NSString *)timeAgoShort;@end 在头文件中 category 可以被用来为相近功能的方法来分组。在 Apple 的 Framework (如下例子取自 NSDate头文件)中这是一种很常见的行为并且我们鼓励在你自己的代码中也这样做。 我们的经验是，创建一组分类对以后的重构很有帮助:一个类的接口增加的时候，可能意味着这个类做了太多事情，违背了单一功能原则，之前创造的分组可以帮助理解不同部分的功能，并且把这个类分成更多独立的部分。 @interface NSDate : NSObject &lt;NSCopying, NSSecureCoding&gt;@property (readonly) NSTimeInterval timeIntervalSinceReferenceDate;@end@interface NSDate (NSDateCreation)+ (instancetype)date;+ (instancetype)dateWithTimeIntervalSinceNow:(NSTimeInterval)secs;+ (instancetype)dateWithTimeIntervalSinceReferenceDate:(NSTimeInterval)ti;+ (instancetype)dateWithTimeIntervalSince1970:(NSTimeInterval)secs;+ (instancetype)dateWithTimeInterval:(NSTimeInterval)secsToBeAdded sinceDate:(NSDate *)date;// ...@end Protocols近些年，在 Objective-C 的世界中对抽象接口的理解有所偏差。Interface 术语通常指一个类的.h文件，但是对 Java 开发者来说还有领一个熟知的含义:用来描述一系列不必具体实现的方法。 在 Objective-C 中上述情况是通过使用 protocols 来实现的。由于历史原因，protocol (Java 中的接口) 并没有在 Objective-C 社区中广泛使用。主要原因是因为 Apple 大部分代码开发者没有使用这种方法的，几乎所有的开发者都倾向于遵从 Apple 的模式和引导。Apple 开发者几乎只在 delegation 模式下使用 protocols。 抽象接口的概念很强大，在计算机科学历史中早有起源，所以在 Objective-C 中也没理由拒绝使用。 这里会通过一个具体例子来展现 protocols (用作抽象接口)用法的强大:从一个非常糟糕的架构设计改造为非常优秀且可复用的代码。 这个例子是实现一个 RSS 订阅器(作为一个技术面试中的测试题来思考下)。 需求很简单:在一个 tableView 中展示远程订阅的 RSS。 一种很幼稚的实现方法可能是创建一个UITableViewController的子类，把订阅信息的检索，解析以及展示所有逻辑都写在一起然后展示在同一个地方，或者说是 “MVC” (Massive View Controller)。这样做是可以运行的，但是设计很糟糕，还是足以通过一些要求不高的面试。 最小步骤应该遵循单一功能原则，至少创建两部分来完成不同的任务： 一个 feed 解析器来解析从终端上获取的结果 一个 feed 阅读器来显示结果 这些类的接口应该是这样的: @interface ZOCFeedParser : NSObject@property (nonatomic, weak) id &lt;ZOCFeedParserDelegate&gt; delegate;@property (nonatomic, strong) NSURL *url;- (id)initWithURL:(NSURL *)url;- (BOOL)start;- (void)stop;@end @interface ZOCTableViewController : UITableViewController- (instancetype)initWithFeedParser:(ZOCFeedParser *)feedParser;@end ZOCFeedParser 通过一个指向终端的 NSURL 初始化来抓取 RSS 订阅(实际上可能会用 NSXMLParser 和 NSXMLParserDelegate 来创建有意义的数据)，ZOCTableViewController 通过 parser 来初始化。我们希望它显示 parser 取回的值，我们通过下方的 protocol 来实现 delegation: @protocol ZOCFeedParserDelegate &lt;NSObject&gt;@optional- (void)feedParserDidStart:(ZOCFeedParser *)parser;- (void)feedParser:(ZOCFeedParser *)parser didParseFeedInfo:(ZOCFeedInfoDTO *)info;- (void)feedParser:(ZOCFeedParser *)parser didParseFeedItem:(ZOCFeedItemDTO *)item;- (void)feedParserDidFinish:(ZOCFeedParser *)parser;- (void)feedParser:(ZOCFeedParser *)parser didFailWithError:(NSError *)error;@end 用合适的 protocol 来处理 RSS 很完美。视图控制器要在公共接口中遵守上述 protocol 的协议: @interface ZOCTableViewController : UITableViewController &lt;ZOCFeedParserDelegate&gt; 最后创建的代码应该是如下的样子: NSURL *feedURL = [NSURL URLWithString:@"http://bbc.co.uk/feed.rss"];ZOCFeedParser *feedParser = [[ZOCFeedParser alloc] initWithURL:feedURL];ZOCTableViewController *tableViewController = [[ZOCTableViewController alloc] initWithFeedParser:feedParser];feedParser.delegate = tableViewController; 到目前为止可能觉得新代码还不错，但是这些代码有多少可以有效复用呢？视图控制器只能处理 ZOCFeedParser 类型的对象:从这点来看，我们只是把代码拆成了两部分，却没做任何其他有价值的事情。 视图控制器的职责应该是”把某某提供的东西展示出来”，但是如果我们只允许其传递 ZOCFeedParser 对象这就无法解决了。 我们修改 parser 加入 ZOCFeedParserParotocol protocol (在 ZOCFeedParserProtocol.h 文件中，ZOCFeedParserDelegate 也在这)。 @protocol ZOCFeedParserProtocol &lt;NSObject&gt;@property (nonatomic, weak) id &lt;ZOCFeedParserDelegate&gt; delegate;@property (nonatomic, strong) NSURL *url;- (BOOL)start;- (void)stop;@end@protocol ZOCFeedParserDelegate &lt;NSObject&gt;@optional- (void)feedParserDidStart:(id&lt;ZOCFeedParserProtocol&gt;)parser;- (void)feedParser:(id&lt;ZOCFeedParserProtocol&gt;)parser didParseFeedInfo:(ZOCFeedInfoDTO *)info;- (void)feedParser:(id&lt;ZOCFeedParserProtocol&gt;)parser didParseFeedItem:(ZOCFeedItemDTO *)item;- (void)feedParserDidFinish:(id&lt;ZOCFeedParserProtocol&gt;)parser;- (void)feedParser:(id&lt;ZOCFeedParserProtocol&gt;)parser didFailWithError:(NSError *)error;@end 注意，ZOCFeedParserDelegate protocol 现在会处理那些遵循新 protocol 的对象，ZOCFeedParser 的接口文件也更加简洁了: @interface ZOCFeedParser : NSObject &lt;ZOCFeedParserProtocol&gt;- (id)initWithURL:(NSURL *)url;@end 由于 ZOCFeedParser 现在遵循 ZOCFeedParserProtocol 协议，它就必须实现所有 required 方法。 这样一来视图控制器可以接受任何遵循新 protocol 的对象，当然对象也会响应 start 和 stop 方法，而且会通过 delegate 属性来传递信息， 视图控制器只需要知道相关对象并且不需要知道具体的实现细节。 @interface ZOCTableViewController : UITableViewController &lt;ZOCFeedParserDelegate&gt;- (instancetype)initWithFeedParser:(id&lt;ZOCFeedParserProtocol&gt;)feedParser;@end 上面代码片的变化看起不大，但是实际上有了很大的提升，因为视图控制器工作时面相抽象接口要比具体实现更好。这样有很多好处: 视图控制器可以通过 delegate 属性接收到由任何对象发出的信息:可以是 RSS 远程订阅解析器，本地解析器，读取其他类型远程数据服务，还可能是抓取本地数据库中数据的服务。 订阅解析器对象可以完整复用(对比第一步重构之前)； ZOCFeedParser 和 ZOCFeedParserDelegate 可以被其他部分复用； ZOCViewController (UI 逻辑部分)可以被复用； 测试更简单，因为可以用 mock 对象来达到 protocol 预期的效果。 当实现一个 protocol 你应该遵守 里氏替换原则。原则的内容是:你应该在不改变客户端或者相关实现的前提下，可以随意用其他实现来替换当前接口(Objective-C 中的 “protocol”)的实现。 换句话说，你的 protocol 不应该暴露任何其实现类的细节;当通过 protocol 来设计抽象表述的时候应该十分小心，时刻谨记它和低层实现是无关的，其真正作用是暴露给使用者的抽象概念。 所有设计的代码以后都可以复用以为着代码的高质量，这也是开发者一直追求的目标。程序设计是区分资深开发者和初级开发者的方法。 最终代码可以在这里找到。 NSNotification当你定义自己的 NSNotification 时你应该把你的通知名定义成一个字符串常量。就想任何你要暴露给其他类使用的字符串常量一样，应该在公共接口中用 extern 声明，并在对应的实现文件里定义。 因为你在头文件中暴露了这个符号，那你应该遵循命名空间规则，用其所属的类名作为该通知名的前缀。 用助动词 Did/Will 来为通知命名，以及用单词 “Notifications” 来作为通知名的后缀都是不错的做法。 // Foo.hextern NSString * const ZOCFooDidBecomeBarNotification// Foo.mNSString * const ZOCFooDidBecomeBarNotification = @&quot;ZOCFooDidBecomeBarNotification&quot;; 美化代码空格 缩进用 4 个空格，不要用 tab 缩进。确定你在 Xcode 中是这样设置的。 方法的大括号和其他的大括号 (if/else/switch/while等等) 通常在当前行开始，在语句结束的时候另起一行。 推荐: if (user.isHappy) &#123; //Do something&#125;else &#123; //Do something else&#125; 不推荐: if (user.isHappy)&#123; //Do something&#125; else &#123; //Do something else&#125; 两个方法之间应该有空行，这样有助于看起来更清晰且有组织。方法内的空格应该是用来分离功能的，但是通常新功能应该用新方法来实现。 优先使用 auto-synthesis。如果一定要用 @synthesize 和 @dynamic 的话应该在实现中另起一行。 冒号对齐这种方法应该尽量避免使用。如果当一个方法表述包含超过 3 个冒号时，冒号对齐就会让代码可读性增强。即使包含 blocks 也要让冒号对齐。 推荐: [UIView animateWithDuration:1.0 animations:^&#123; // something &#125; completion:^(BOOL finished) &#123; // something &#125;]; 不推荐: [UIView animateWithDuration:1.0 animations:^&#123; // something&#125; completion:^(BOOL finished) &#123; // something&#125;]; 如果自动对齐降低了可读性，那么应该提前把 block 定义为变量，或者重新考虑这个方法的格式设计。 换行由于本指南关注代码的显示效果和可读性，所以换行是一个重要的主题。 例如: self.productsRequest = [[SKProductsRequest alloc] initWithProductIdentifiers:productIdentifiers]; 依照本指南，像上述一行很长的代码应该以一个间隔(两个空格)另起一行。 self.productsRequest = [[SKProductsRequest alloc] initWithProductIdentifiers:productIdentifiers]; 括号在如下场景使用 Egyptain 括号(又称 K&amp;R 风格，代码段括号的开始位于一行的末尾，而不是另外起一行的风格): 控制语句(if-else, for, switch) 非 Egyptain 括号在以下情况可以使用: 类的实现(如果存在) 方法的实现 代码组织引用自 Mattt Thompson 代码组织就是卫生问题 非常赞成这句话。用整洁规范的方法来组织代码，是对自己和其他要读和修改你代码的人的尊重(包括以后你自己)。 利用代码块GCC 有一个很隐蔽的特性，同时 Clang 也支持这个特性，就是在闭合的大括号内部，代码块会返回最后一行语句的值。 NSURL *url = (&#123; NSString *urlString = [NSString stringWithFormat:@&quot;%@/%@&quot;, baseURLString, endpoint]; [NSURL URLWithString:urlString];&#125;); 这个特性可以很有效的组织一段代码，这段代码通常只是为了实例化一个类这个目的而存在的。 这给了看代码的人一个重要的视觉提示，降低了视觉上的干扰，专注于函数最重要的变量。 此外，这个技巧的好处在于，所有在代码块中定义的变量，只在括号内部有效，这就意味着不会污染堆栈轨迹，你可以重复使用变量名而不会出现 duplicated symbols 错误。 PragmaPragma Mark#pragma mark - 是类内部组织代码很有效的方法，帮助将方法实现进行分类。 我们建议用 #pragma mark - 来分隔: 不同组的方法 protocols 的实现 父类方法的重载 - (void)dealloc &#123; /* ... */ &#125;- (instancetype)init &#123; /* ... */ &#125;#pragma mark - View Lifecycle- (void)viewDidLoad &#123; /* ... */ &#125;- (void)viewWillAppear:(BOOL)animated &#123; /* ... */ &#125;- (void)didReceiveMemoryWarning &#123; /* ... */ &#125;#pragma mark - Custom Accessors- (void)setCustomProperty:(id)value &#123; /* ... */ &#125;- (id)customProperty &#123; /* ... */ &#125;#pragma mark - IBActions- (IBAction)submitData:(id)sender &#123; /* ... */ &#125;#pragma mark - Public- (void)publicMethod &#123; /* ... */ &#125;#pragma mark - Private- (void)zoc_privateMethod &#123; /* ... */ &#125;#pragma mark - UITableViewDataSource- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123; /* ... */ &#125;#pragma mark - ZOCSuperclass// ... overridden methods from ZOCSuperclass#pragma mark - NSObject- (NSString *)description &#123; /* ... */ &#125; 上述的标记可以有效的分离和组织代码。还可以 cmd+click 点击 mark 跳转到符号定义的地方。 要注意的是，用 pragma mark 也是一种手艺，这不是你在类中过度增加方法的原因：类里面有太多说明方法说明这个类做了太多，需要重构了。 Pragma 注意在 http://raptureinvenice.com/pragmas-arent-just-for-marks 这里有关于 pragma 的一次非常棒的讨论，这里做部分说明。 大部分 iOS 开发者平时不太会关注编译器选项，很多选项对于控制检查(或者不检查)代码错误的严格度十分有效。有时你想要用 pragma 在代码中直接抛出异常，用来临时打断编译器的行为。 当在用 ARC 的时候，编译器替你插入内存管理调用方法，有些情况下会让人混淆。比如当你使用 NSSelectorFromString 来动态产生一个 selector 调用的时候，由于 ARC 不知道这个方法是什么，也不知道应该用什么类型的内存管理方式，就会被警告performSelector may cause a leak because its selector is unknown(由于 selector 未知，执行可能导致内存泄露)。 如果你清楚你的代码不会内存泄漏，你可以通过用这些代码忽略警告 #pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;[myObj performSelector:mySelector withObject:name];#pragma clang diagnostic pop 注意我们是如何在代码前后用 push 和 pop 来停用 -Warc-performSelector-leaks 检查的。确保我们没有全局禁用，全局禁用会导致错误。 打开和关闭的所有选项可以在The Clang User’s Manual 找到和学习。 忽略没有使用变量的编译警告提示一个定义但未被使用的变量是很有用的。大部分情况下，你想移除这些引用来提高一些性能，但是有时你又想保留他们。为什么？可能以后会用，或者只是暂时移除功能。无论如何，除了粗暴的注释掉相关的代码行之外，消除这些警告的有效办法是用 #pragma unused(): - (NSInteger)giveMeFive&#123; NSString *foo; #pragma unused (foo) return 5;&#125; 现在就可以在编译器不会编译这些代码的情况下保留他们了。同时，pragma 要标记在问题代码的下方。 明确编译器警告和错误编译器毕竟是个机器人，他会用 Clang 定义的一些规则来标记你代码中的错误。但是你你总是比编译器要聪明的。通常你会发现有些烦人的代码会出问题，但是因为某种原因你暂时没办法修复。你可以明确的像下面这样标记 error： - (NSInteger)divide:(NSInteger)dividend by:(NSInteger)divisor&#123; #error Whoa, buddy, you need to check for zero here! return (dividend / divisor);&#125; 类似的你可以这样标记一个 warning： - (float)divide:(float)dividend by:(float)divisor&#123; #warning Dude, don&apos;t compare floating point numbers like this! if (divisor != 0.0) &#123; return (dividend / divisor); &#125; else &#123; return NAN; &#125;&#125; 字符串文档所有重要的方法、接口、分类和协议的定义应该伴有描述来表明他们的用途和使用方法。更多例子可以看 Google Style Guide 中 File and Declaration Comments. 总而言之，有两种字符串文档注释，长字符串文档和短字符串文档。 短字符串文档适合只有一行的情况，这其中包括斜杠。它适用于简单的函数，尤其是(不仅仅)非 public API 中。 // Return a user-readable form of a Frobnozz, html-escaped. 注意文本描述应该用 “return” 这种行为动词而非 “returns”。 如果描述超过一行，你应该用长字符串文档： 以/**开始 换行写一句总结的话，以?或者!或者.结尾。 空一行 在与第一行对齐的位置开始写剩下的注释 最后用*/结束。 /** This comment serves to demonstrate the format of a docstring. Note that the summary line is always at most one line long, and after the opening block comment, and each line of text is preceded by a single space.*/ 一个函数必须有字符串文档除非下述所有条件： 非共有 很短 功能明确 注释文档应该描述调用的时机和其使用场景，而不是具体实现。 注释注释存在的意义是解释特定的代码的用途。所有的注释都应该保持最新的版本，否则就直接删掉。 通常要避免块注释，因为代码本身就应该尽可能的表达语意，就算要写注释也尽可能几行搞定。例外：不包括那些要抽离出来生成文档的注释。 头文档类的头文档应该只在 .h 文件中遵守 Doxygen/AppleDoc 的语法书写。方法和属性都应该提供文档。 例如： /** * Designated initializer. * * @param store The store for CRUD operations. * @param searchService The search service used to query the store. * * @return A ZOCCRUDOperationsStore object. */- (instancetype)initWithOperationsStore:(id&lt;ZOCGenericStoreProtocol&gt;)store searchService:(id&lt;ZOCGenericSearchServiceProtocol&gt;)searchService;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[正则表达式入门守则]]></title>
      <url>%2F2015%2F08%2F17%2F2015-08-17-Regular-Expression%2F</url>
      <content type="text"><![CDATA[多数语言都支持的「正则表达式」这篇文章转载和整理自「原文」。 入门学习正则表达式的最好方法是从例子开始，理解例子之后再自己对例子进行修改，实验。下面给出了不少简单的例子，并对它们作了详细的说明。 假设你在一篇英文小说里查找 hi，你可以使用正则表达式hi。 这几乎是最简单的正则表达式了，它可以精确匹配这样的字符串：由两个字符组成，前一个字符是h,后一个是i。通常，处理正则表达式的工具会提供一个忽略大小写的选项，如果选中了这个选项，它可以匹配 hi, HI, Hi, hI 这四种情况中的任意一种。 不幸的是，很多单词里包含hi这两个连续的字符，比如 him, history, high 等等。用hi来查找的话，这里边的 hi 也会被找出来。如果要精确地查找hi这个单词的话，我们应该使用\bhi\b。 \b是正则表达式规定的一个特殊代码（好吧，某些人叫它元字符，metacharacter），代表着单词的开头或结尾，也就是单词的分界处。虽然通常英文的单词是由空格，标点符号或者换行来分隔的，但是\b并不匹配这些单词分隔字符中的任何一个，它只匹配一个位置。 假如你要找的是hi后面不远处跟着一个Lucy，你应该用\bhi\b.*\bLucy\b。 如果需要更精确的说法，\b匹配这样的位置：它的前一个字符和后一个字符不全是(一个是,一个不是或不存在)\w。 这里，.是另一个元字符，匹配除了换行符以外的任意字符。*同样是元字符，不过它代表的不是字符，也不是位置，而是数量——它指定*前边的内容可以连续重复使用任意次以使整个表达式得到匹配。因此，.和*连在一起就意味着任意数量的不包含换行的字符。现在bhi\b.*\bLucy\b的意思就很明显了：先是一个单词 hi ,然后是任意个任意字符(但不能是换行)，最后是 Lucy 这个单词。 换行符就是\n,ASCII编码为10(十六进制0x0A)的字符。 如果同时使用其它元字符，我们就能构造出功能更强大的正则表达式。比如下面这个例子： 0\d\d-\d\d\d\d\d\d\d\d匹配这样的字符串：以0开头，然后是两个数字，然后是一个连字号“-”，最后是8个数字(也就是中国的电话号码。当然，这个例子只能匹配区号为3位的情形)。 这里的\d是个新的元字符，匹配一位数字(0，或1，或2，或……)。-不是元字符，只匹配它本身——连字符(或者减号，或者中横线，或者随你怎么称呼它)。 为了避免那么多烦人的重复，我们也可以这样写这个表达式：0\d{2}-\d{8}。这里\d后面的{2}和{8}的意思是前面\d必须连续重复匹配2次(8次)。 元字符现在你已经知道几个很有用的元字符了，如\b,.,*，还有\d.正则表达式里还有更多的元字符，比如\s匹配任意的空白符，包括空格，制表符(Tab)，换行符，中文全角空格等。\w匹配字母或数字或下划线或汉字等。 对中文/汉字的特殊处理是由.Net提供的正则表达式引擎支持的，其它环境下的具体情况请查看相关文档。 下面来看看更多的例子： \ba\w*\b匹配以字母a开头的单词——先是某个单词开始处(\b)，然后是字母a,然后是任意数量的字母或数字(\w*)，最后是单词结束处(\b)。 好吧，现在我们说说正则表达式里的单词是什么意思吧：就是不少于一个的连续的\w。不错，这与学习英文时要背的成千上万个同名的东西的确关系不大 :) \d+匹配1个或更多连续的数字。这里的+是和*类似的元字符，不同的是*匹配重复任意次(可能是0次)，而+则匹配重复1次或更多次。 \b\w{6}\b 匹配刚好6个字符的单词。 代码 说明 . 匹配除换行符以外的任意字符 \w 匹配字母或数字或下划线或汉字 \s 匹配任意的空白符 \d 匹配数字 \b 匹配单词的开始或结束 ^ 匹配字符串的开始 $ 匹配字符串的结束 正则表达式引擎通常会提供一个“测试指定的字符串是否匹配一个正则表达式”的方法，如JavaScript里的RegExp.test()方法或.NET里的Regex.IsMatch()方法。这里的匹配是指是字符串里有没有符合表达式规则的部分。如果不使用^和$的话，对于\d{5,12}而言，使用这样的方法就只能保证字符串里包含5到12连续位数字，而不是整个字符串就是5到12位数字。 元字符^（和数字6在同一个键位上的符号）和$都匹配一个位置，这和\b有点类似。^匹配你要用来查找的字符串的开头，$匹配结尾。这两个代码在验证输入的内容时非常有用，比如一个网站如果要求你填写的QQ号必须为5位到12位数字时，可以使用：^\d{5,12}$。 这里的{5,12}和前面介绍过的{2}是类似的，只不过{2}匹配只能不多不少重复2次，{5,12}则是重复的次数不能少于5次，不能多于12次，否则都不匹配。 因为使用了^和$，所以输入的整个字符串都要用来和\d{5,12}来匹配，也就是说整个输入必须是5到12个数字，因此如果输入的QQ号能匹配这个正则表达式的话，那就符合要求了。 和忽略大小写的选项类似，有些正则表达式处理工具还有一个处理多行的选项。如果选中了这个选项，^和$的意义就变成了匹配行的开始处和结束处。 字符转义如果你想查找元字符本身的话，比如你查找.,或者*,就出现了问题：你没办法指定它们，因为它们会被解释成别的意思。这时你就得使用\来取消这些字符的特殊意义。因此，你应该使用\.和\*。当然，要查找\本身，你也得用\\. 例如：deerchao\.net匹配deerchao.net，C:\\Windows匹配C:\Windows。 重复你已经看过了前面的*,+,{2},{5,12}这几个匹配重复的方式了。下面是正则表达式中所有的限定符(指定数量的代码，例如*,{5,12}等 代码/语法 说明 * 重复零次或更多次 + 重复一次或更多次 ? 重复零次或一次 {n} 重复n次 {n,} 重复n次或更多次 {n,m} 重复n到m次 下面是一些使用重复的例子： Windows\d+匹配Windows后面跟1个或更多数字 ^\w+匹配一行的第一个单词(或整个字符串的第一个单词，具体匹配哪个意思得看选项设置) 字符类要想查找数字，字母或数字，空白是很简单的，因为已经有了对应这些字符集合的元字符，但是如果你想匹配没有预定义元字符的字符集合(比如元音字母a,e,i,o,u),应该怎么办？ 很简单，你只需要在方括号里列出它们就行了，像[aeiou]就匹配任何一个英文元音字母，[.?!]匹配标点符号(.或?或!)。 我们也可以轻松地指定一个字符范围，像[0-9]代表的含意与\d就是完全一致的：一位数字；同理[a-z0-9A-Z_]也完全等同于\w（如果只考虑英文的话）。 下面是一个更复杂的表达式：\(?0\d{2}[) -]?\d{8}。 “(”和“)”也是元字符，后面的分组节里会提到，所以在这里需要使用转义。 这个表达式可以匹配几种格式的电话号码，像(010)88886666，或022-22334455，或02912345678等。我们对它进行一些分析吧：首先是一个转义字符\(,它能出现0次或1次(?),然后是一个0，后面跟着2个数字(\d{2})，然后是)或-或空格中的一个，它出现1次或不出现(?)，最后是8个数字(\d{8})。 分枝条件不幸的是，刚才那个表达式也能匹配010)12345678或(022-87654321这样的“不正确”的格式。要解决这个问题，我们需要用到分枝条件。正则表达式里的分枝条件指的是有几种规则，如果满足其中任意一种规则都应该当成匹配，具体方法是用|把不同的规则分隔开。听不明白？没关系，看例子： 0\d{2}-\d{8}|0\d{3}-\d{7}这个表达式能匹配两种以连字号分隔的电话号码：一种是三位区号，8位本地号(如010-12345678)，一种是4位区号，7位本地号(0376-2233445)。 \(?0\d{2}\)?[- ]?\d{8}|0\d{2}[- ]?\d{8}这个表达式匹配3位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔。你可以试试用分枝条件把这个表达式扩展成也支持4位区号的。 \d{5}-\d{4}|\d{5}这个表达式用于匹配美国的邮政编码。美国邮编的规则是5位数字，或者用连字号间隔的9位数字。之所以要给出这个例子是因为它能说明一个问题：使用分枝条件时，要注意各个条件的顺序。如果你把它改成\d{5}|\d{5}-\d{4}的话，那么就只会匹配5位的邮编(以及9位邮编的前5位)。原因是匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了。 分组我们已经提到了怎么重复单个字符（直接在字符后面加上限定符就行了）；但如果想要重复多个字符又该怎么办？你可以用小括号来指定子表达式(也叫做分组)，然后你就可以指定这个子表达式的重复次数了，你也可以对子表达式进行其它一些操作(后面会有介绍)。 (\d{1,3}\.){3}\d{1,3}是一个简单的IP地址匹配表达式。要理解这个表达式，请按下列顺序分析它：\d{1,3}匹配1到3位的数字，(\d{1,3}\.){3}匹配三位数字加上一个英文句号(这个整体也就是这个分组)重复3次，最后再加上一个一到三位的数字(\d{1,3})。 IP地址中每个数字都不能大于255. 经常有人问我, 01.02.03.04 这样前面带有0的数字, 是不是正确的IP地址呢? 答案是: 是的, IP 地址里的数字可以包含有前导 0 (leading zeroes). 不幸的是，它也将匹配256.300.888.999这种不可能存在的IP地址。如果能使用算术比较的话，或许能简单地解决这个问题，但是正则表达式中并不提供关于数学的任何功能，所以只能使用冗长的分组，选择，字符类来描述一个正确的IP地址：((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)。 理解这个表达式的关键是理解2[0-4]\d|25[0-5]|[01]?\d\d?，这里我就不细说了，你自己应该能分析得出来它的意义。 反义有时需要查找不属于某个能简单定义的字符类的字符。比如想查找除了数字以外，其它任意字符都行的情况，这时需要用到反义： 代码/语法 说明 \W 匹配任意不是字母，数字，下划线，汉字的字符 \S 匹配任意不是空白符的字符 \D 匹配任意非数字的字符 \B 匹配不是单词开头或结束的位置 [^x] 匹配除了x以外的任意字符 [^aeiou] 匹配除了aeiou这几个字母以外的任意字符 例子：\S+匹配不包含空白符的字符串。 &lt;a[^&gt;]+&gt;匹配用尖括号括起来的以a开头的字符串。 后向引用使用小括号指定一个子表达式后，匹配这个子表达式的文本(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。默认情况下，每个分组会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。 其实,组号分配还不像我刚说得那么简单： 分组0对应整个正则表达式 实际上组号分配过程是要从左向右扫描两遍的：第一遍只给未命名组分配，第二遍只给命名组分配－－因此所有命名组的组号都大于未命名的组号 你可以使用(?:exp)这样的语法来剥夺一个分组对组号分配的参与权． 后向引用用于重复搜索前面某个分组匹配的文本。例如，\1代表分组1匹配的文本。难以理解？请看示例： \b(\w+)\b\s+\1\b可以用来匹配重复的单词，像go go, 或者kitty kitty。这个表达式首先是一个单词，也就是单词开始处和结束处之间的多于一个的字母或数字(\b(\w+)\b)，这个单词会被捕获到编号为1的分组中，然后是1个或几个空白符(\s+)，最后是分组1中捕获的内容（也就是前面匹配的那个单词）(\1)。 你也可以自己指定子表达式的组名。要指定一个子表达式的组名，请使用这样的语法：(?&lt;Word&gt;\w+)(或者把尖括号换成’也行：(?&#39;Word&#39;\w+)),这样就把\w+的组名指定为Word了。要反向引用这个分组捕获的内容，你可以使用\k&lt;Word&gt;,所以上一个例子也可以写成这样：\b(?&lt;Word&gt;\w+)\b\s+\k&lt;Word&gt;\b。 使用小括号的时候，还有很多特定用途的语法。下面列出了最常用的一些： 分类 代码/语法 说明 捕获 (exp) 匹配exp,并捕获文本到自动命名的组里 (?&lt;name&gt;exp) 匹配exp,并捕获文本到名称为name的组里，也可以写成(?’name&#39;exp) (?:exp) 匹配exp,不捕获匹配的文本，也不给此分组分配组号 零宽断言 (?=exp) 匹配exp前面的位置 (?&lt;=exp) 匹配exp后面的位置 (?!exp) 匹配后面跟的不是exp的位置 (?&lt;!exp) 匹配前面不是exp的位置 注释 (?#comment) 这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读 我们已经讨论了前两种语法。第三个(?:exp)不会改变正则表达式的处理方式，只是这样的组匹配的内容不会像前两种那样被捕获到某个组里面，也不会拥有组号。“我为什么会想要这样做？”——好问题，你觉得为什么呢？ 零宽断言接下来的四个用于查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们像\b,^,$那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为零宽断言。最好还是拿例子来说明吧： 断言用来声明一个应该为真的事实。正则表达式中只有当断言为真时才会继续进行匹配。 (?=exp)也叫零宽度正预测先行断言，它断言自身出现的位置的后面能匹配表达式exp。比如\b\w+(?=ing\b)，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找I’m singing while you’re dancing.时，它会匹配sing和danc。 (?&lt;=exp)也叫零宽度正回顾后发断言，它断言自身出现的位置的前面能匹配表达式exp。比如(?&lt;=\bre)\w+\b会匹配以re开头的单词的后半部分(除了re以外的部分)，例如在查找reading a book时，它匹配ading。 假如你想要给一个很长的数字中每三位间加一个逗号(当然是从右边加起了)，你可以这样查找需要在前面和里面添加逗号的部分：((?&lt;=\d)\d{3})+\b，用它对1234567890进行查找时结果是234567890。 下面这个例子同时使用了这两种断言：(?&lt;=\s)\d+(?=\s)匹配以空白符间隔的数字(再次强调，不包括这些空白符)。 负向零宽断言前面我们提到过怎么查找不是某个字符或不在某个字符类里的字符的方法(反义)。但是如果我们只是想要确保某个字符没有出现，但并不想去匹配它时怎么办？例如，如果我们想查找这样的单词–它里面出现了字母q,但是q后面跟的不是字母u,我们可以尝试这样： \b\w*q[^u]\w*\b匹配包含后面不是字母u的字母q的单词。但是如果多做测试(或者你思维足够敏锐，直接就观察出来了)，你会发现，如果q出现在单词的结尾的话，像Iraq,Benq，这个表达式就会出错。这是因为[^u]总要匹配一个字符，所以如果q是单词的最后一个字符的话，后面的[^u]将会匹配q后面的单词分隔符(可能是空格，或者是句号或其它的什么)，后面的\w*\b将会匹配下一个单词，于是\b\w*q[^u]\w*\b就能匹配整个Iraq fighting。负向零宽断言能解决这样的问题，因为它只匹配一个位置，并不消费任何字符。现在，我们可以这样来解决这个问题：\b\w*q(?!u)\w*\b。 零宽度负预测先行断言(?!exp)，断言此位置的后面不能匹配表达式exp。例如：\d{3}(?!\d)匹配三位数字，而且这三位数字的后面不能是数字；\b((?!abc)\w)+\b匹配不包含连续字符串abc的单词。 同理，我们可以用(?&lt;!exp),零宽度负回顾后发断言来断言此位置的前面不能匹配表达式exp：(?&lt;![a-z])\d{7}匹配前面不是小写字母的七位数字。 请详细分析表达式(?&lt;=&lt;(\w+)&gt;).*(?=&lt;\/\1&gt;)，这个表达式最能表现零宽断言的真正用途。 一个更复杂的例子：(?&lt;=&lt;(\w+)&gt;).*(?=&lt;\/\1&gt;)匹配不包含属性的简单HTML标签内里的内容。(?&lt;=&lt;(\w+)&gt;)指定了这样的前缀：被尖括号括起来的单词(比如可能是&lt;b&gt;)，然后是.*(任意的字符串),最后是一个后缀(?=&lt;\/\1&gt;)。注意后缀里的\/，它用到了前面提过的字符转义；\1则是一个反向引用，引用的正是捕获的第一组，前面的(\w+)匹配的内容，这样如果前缀实际上是&lt;b&gt;的话，后缀就是&lt;/b&gt;了。整个表达式匹配的是&lt;b&gt;和&lt;/b&gt;之间的内容(再次提醒，不包括前缀和后缀本身)。 注释小括号的另一种用途是通过语法(?#comment)来包含注释。例如：2[0-4]\d(?#200-249)|25[0-5](?#250-255)|[01]?\d\d?(?#0-199)。 要包含注释的话，最好是启用“忽略模式里的空白符”选项，这样在编写表达式时能任意的添加空格，Tab，换行，而实际使用时这些都将被忽略。启用这个选项后，在#后面到这一行结束的所有文本都将被当成注释忽略掉。例如，我们可以前面的一个表达式写成这样： (?&lt;= # 断言要匹配的文本的前缀&lt;(\w+)&gt; # 查找尖括号括起来的字母或数字(即HTML/XML标签)) # 前缀结束.* # 匹配任意文本(?= # 断言要匹配的文本的后缀&lt;\/\1&gt; # 查找尖括号括起来的内容：前面是一个"/"，后面是先前捕获的标签) # 后缀结束 贪婪与懒惰当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。以这个表达式为例：a.*b，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，它会匹配整个字符串aabab。这被称为贪婪匹配。 有时，我们更需要懒惰匹配，也就是匹配尽可能少的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号?。这样.*?就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。现在看看懒惰版的例子吧： a.*?b匹配最短的，以a开始，以b结束的字符串。如果把它应用于aabab的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）。 为什么第一个匹配是aab（第一到第三个字符）而不是ab（第二到第三个字符）？简单地说，因为正则表达式有另一条规则，比懒惰／贪婪规则的优先级更高：最先开始的匹配拥有最高的优先权——The match that begins earliest wins。 代码/语法 说明 *? 重复任意次，但尽可能少重复 +? 重复1次或更多次，但尽可能少重复 ?? 重复0次或1次，但尽可能少重复 {n,m}? 重复n到m次，但尽可能少重复 {n,}? 重复n次以上，但尽可能少重复 还有些什么东西没提到上边已经描述了构造正则表达式的大量元素，但是还有很多没有提到的东西。下面是一些未提到的元素的列表，包含语法和简单的说明。你可以在网上找到更详细的参考资料来学习它们–当你需要用到它们的时候。如果你安装了MSDN Library,你也可以在里面找到.net下正则表达式详细的文档。这里的介绍很简略，如果你需要更详细的信息，而又没有在电脑上安装MSDN Library,可以查看关于正则表达式语言元素的MSDN在线文档。 代码/语法 说明 \a 报警字符(打印它的效果是电脑嘀一声) \b 通常是单词分界位置，但如果在字符类里使用代表退格 \t 制表符，Tab \r 回车 \v 竖向制表符 \f 换页符 \n 换行符 \e Escape \0nn ASCII代码中八进制代码为nn的字符 \xnn ASCII代码中十六进制代码为nn的字符 \unnnn Unicode代码中十六进制代码为nnnn的字符 \cN ASCII控制字符。比如\cC代表Ctrl+C \A 字符串开头(类似^，但不受处理多行选项的影响) \Z 字符串结尾或行尾(不受处理多行选项的影响) \z 字符串结尾(类似$，但不受处理多行选项的影响) \G 当前搜索的开头 \p{name} Unicode中命名为name的字符类，例如\p{IsGreek} (?&gt;exp) 贪婪子表达式 (?&lt;x&gt;-&lt;y&gt;exp) 平衡组 (?im-nsx:exp) 在子表达式exp中改变处理选项 (?im-nsx) 为表达式后面的部分改变处理选项 (?(exp)yes\ no) (?(exp)yes) 同上，只是使用空表达式作为no (?(name)yes\ no) (?(name)yes) 同上，只是使用空表达式作为no]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Cocoapods 的安装、使用及其配置]]></title>
      <url>%2F2015%2F08%2F10%2F2015-08-10-Cocoapods%2F</url>
      <content type="text"><![CDATA[项目中有第三方库？不用 Cocoapods 真是你的损失呐。 Basic如果你只是想用 Cocoapods 把第三方库导入你的工程，本章内容目的就是以最快速度让你把 Cocoapods 应用到你的项目中。 InstallationCocoapods 基于 Ruby，OS X 已经安装好 Ruby。限于国内的网络，此处先修改 RubyGems 源的地址。 $ gem sources --remove https://rubygems.org/$ gem sources -a http://ruby.taobao.org/ 执行完毕后，验证是否修改成功。 $ gem sources -l 如果显示如下信息代表修改成功。 *** CURRENT SOURCES *** http://ruby.taobao.org/ 接下来安装 Cocoapods $ sudo gem install cocoapods Usage如果你还没装 Alcatraz，那请你先安装 Alcatraz。 curl -fsSL https://raw.github.com/supermarin/Alcatraz/master/Scripts/install.sh | sh 进入你要添加第三方库的工程，按command + shift + 9调出 Alcatraz 搜索界面，搜索 Cocoapods 并安装。 安装完毕后，重启 Xcode，如下图点击创建 Podfile。 以 AFNetworking为例，在 Podfile 文件中写入并保存。 platform :ios, "7.0"pod "AFNetworking" 这时 Cocoapods 插件已经可以选择安装了。 点击安装 提示重新启动并打开 .workspace文件，现在你已经可以愉快的引用 AFNetworking.h咯！ Advanced本章内容有助于你提高对 Cocoapods 更深层次的理解。 Commands1. pod install 根据在 Podfile 中配置好的第三方库信息来安装对应的库。 如果存在 Podfile.lock 文件则根据 Podfile.lock 中锁定的版本进行安装。 每次更新了Podfile文件时，都需要重新执行该命令，以便重新安装Pods依赖库。 2. pod update 很多情况下，Podfile 中的第三方库信息格式并没有指定某个库的具体版本，那么在执行 pod update后，第三方库都会更新到最新版本且 Podfile.lock 会一同更新。 3. pod search 执行 $ pod search AFNetworking 得到如下信息： -&gt; AFNetworking (2.5.4) A delightful iOS and OS X networking framework. pod 'AFNetworking', '~&gt; 2.5.4' - Homepage: https://github.com/AFNetworking/AFNetworking - Source: https://github.com/AFNetworking/AFNetworking.git - Versions: 2.5.4, 2.5.3, 2.5.2, 2.5.1, 2.5.0, 2.4.1, 2.4.0, 2.3.1, 2.3.0, 2.2.4, 2.2.3, 2.2.2, 2.2.1, 2.2.0, 2.1.0, 2.0.3, 2.0.2, 2.0.1, 2.0.0, 2.0.0-RC3, 2.0.0-RC2, 2.0.0-RC1, 1.3.4, 1.3.3, 1.3.2, 1.3.1, 1.3.0, 1.2.1, 1.2.0, 1.1.0, 1.0.1, 1.0, 1.0RC3, 1.0RC2, 1.0RC1, 0.10.1, 0.10.0, 0.9.2, 0.9.1, 0.9.0, 0.7.0, 0.5.1 [master repo] - Subspecs: - AFNetworking/Serialization (2.5.4) - AFNetworking/Security (2.5.4) - AFNetworking/Reachability (2.5.4) - AFNetworking/NSURLConnection (2.5.4) - AFNetworking/NSURLSession (2.5.4) - AFNetworking/UIKit (2.5.4) 选择你的目的版本配置到 Podfile 文件中。 4. pod setup 在本地 Cocoapods 会保存一个 Pods 依赖库的 tree，这个 tree 和服务端的 tree 可能会不同步。因为大量第三方库的作者每天都在维护自己的库，会更新库的版本，执行 $ pod setup 可以让本地依赖库的 tree 与服务端同步。 Usage上一章中，介绍了通过 Xcode 插件来实现利用 Cocoapods 引入第三方库的方法。然而很多程序员觉得还是用命令行界面去操作这一切才更 Cool。 下文以 YOUR_PROJECT代替项目路径为例，介绍下命令行中 Cocoapods 的使用方法。 $ cd YOUR_PROJECT$ touch Podfile 打开你的 Xcode 或者 其他编辑器也行，开始编辑 Podfile，此处依旧以 AFNetworking为例 platform :ios, "7.0"pod "AFNetworking" 编辑好后，还在YOUR_PROJECT路径下，执行 $ pod install 正常情况下将会出现如下提示 Updating local specs repositoriesAnalyzing dependenciesDownloading dependenciesInstalling AFNetworking (2.5.4)Generating Pods projectIntegrating client projectSending stats 然后打开你项目的 .workspace文件，就可以轻松的使用第三方库了。 Principle为什么我们执行这几条指令就可以使用第三方库了？ 首先我们注意到，用 Cocoapods 安装第三方库后，不再打开原工程文件，而是打开一个.workspace的文件。实际上在 Cocoapods 为我们安装第三方库的过程中，它做了如下几件事： 将目的第三方库以 target 的方式导入 将这些 target 组合成一个名为 Pods 的工程 生成 libPods.a 静态库供原工程使用 原工程和第三方库生成的 Pods 工程组合成新的 .workspace PodfilePodfile 就是用来描述一个或者多个 Xcode 工程中 targets 和第三方库的依赖关系。默认情况下只在用户工程的第一个 target中生效。 1. 多个 target 共用依赖 Pods 以两个 target 分别为 MyApp1 和 MyApp2 为例，用link_with即可。 platform :osx, '10.7'link_with 'MyApp1', 'MyApp2'pod 'AFNetworking', '~&gt; 2.0'pod 'Objection', '0.9' 2. 多个 target 依赖不同 Pods 第一个名为 MyApp1 的 target 依赖于 ObjectiveSugar 和 Artsy+UILabels，第二个名为 MyApp2 的 target 依赖于 OCMock。 platform :ios, '8.0'target :MyApp1 do pod 'ObjectiveSugar', '~&gt; 0.5' pod 'Artsy+UILabels', '~&gt; 1.0'endtarget :MyApp2 do pod 'OCMock', '~&gt; 2.0.1'end 3. 关于版本 可以不写版本，也可以指定某个版本，当然也可以使用一些逻辑运算符。 &#39;&gt; 0.1&#39; 比 0.1 高的所有版本 &#39;&gt;= 0.1’ 高于或者等于 0.1 的所有版本 &#39;&lt; 0.1’ 低于 0.1 的所有版本 &#39;&lt;= 0.1&#39; 低于或者等于 0.1 的所有版本 CocoaPods 中有个特殊的逻辑运算符 ~&gt;: &#39;~&gt; 0.1.2’ 包含 0.1.2 这个版本，最高不超过 0.2，不包括 0.2 或者更高版本 &#39;~&gt; 0.1’ 包含 0.1 这个版本，最高不超过 1.0，不包括 1.0 或者更高版本 &#39;~&gt; 0’ 版本 0 或者更高，和没写一样。 更多关于版本的相关信息和规则，下方扩展阅读： Semantic Versioning RubyGems Versioning Policies Podfile.lockIssue很多人都有一种困惑，从 GitHub 行 clone 下来别人的工程，看 Podfile 中对 AFNetworking这个第三方库的描述是这样 pod "AFNetworking", '~&gt; 2.5.2' 而经过 pod search afnetworking 发现当前最新的版本已经是 2.5.6 这时当你在项目目录下执行了 pod install 按理说应该安装 2.6.0 版本以内的最近版本，也就是 2.5.6，实际上发现还是安装了 2.5.2 ，这就是 Podfile.lock 存在的意义。 Necessity假如没有 Podfile.lock，那么在团队开发中绝对是一种灾难。假设 A 君和 B 君在协作开发同一个项目。A君作为这个项目的创建者，在 Podfile 中对AFNetworking的描述是 pod "AFNetworking", '~&gt; 2.5.2' 当 B 君 check out 这个项目时，AFNetworking这个库已经更新到了 2.5.5，那他在 pod install 之后，他本地的这个项目就会依赖于 2.5.5 版本的 AFNetworking。如果这几代版本更迭修改了一些方法的名称，那项目里将会各种 error。 很多人会说，那直接锁定某个版本的AFNetworking，不就不会出现这个问题了？但是开源库的优化是随时进行的，同时还伴随修复 Bug 等操作，所以锁定某个版本的行为是不可取的。 好在有 Podfile.lock，在 A 君第一次执行 pod install 之后，会在 Podfile.lock 中生成如下描述 PODS: - AFNetworking (2.5.2): - AFNetworking/NSURLConnection (= 2.5.2) - AFNetworking/NSURLSession (= 2.5.2) - AFNetworking/Reachability (= 2.5.2) - AFNetworking/Security (= 2.5.2) - AFNetworking/Serialization (= 2.5.2) - AFNetworking/UIKit (= 2.5.2) - AFNetworking/NSURLConnection (2.5.2): - AFNetworking/Reachability - AFNetworking/Security - AFNetworking/Serialization - AFNetworking/NSURLSession (2.5.2): - AFNetworking/Reachability - AFNetworking/Security - AFNetworking/Serialization - AFNetworking/Reachability (2.5.2) - AFNetworking/Security (2.5.2) - AFNetworking/Serialization (2.5.2) - AFNetworking/UIKit (2.5.2): - AFNetworking/NSURLConnection - AFNetworking/NSURLSessionDEPENDENCIES: - AFNetworking (~&gt; 2.5.2)SPEC CHECKSUMS: AFNetworking: fefbce9660acb17f48ae0011292d4da0f457bf36COCOAPODS: 0.38.2 这时 B 君 check out 此项目之后，执行 pod install Cocoapods 会安装在 Podfile.lock 中描述的版本，而不会按照 Podfile 中的逻辑运算安装最新的 2.5.5 。 在协同开发的时候，记得要一并同步 Podfile.lock，它会保证在 Podfile 中描述逻辑允许的情况下，锁定安装 Podfile.lock 描述中的版本。 只有在 pod update 之后，才会检查最新的版本，并且重写 Podfile.lock 中对第三方库的版本描述。 通常情况下，我们无必要手动修改 Podfile.lock 中的内容，但是将它从.gitignore中移除是十分必要的。 Q &amp; A一些可能遇到的问题和对应的解决答案，我踩过的坑，你就别踩了。 Q1: 用 gem 安装 Cocoapods 提示 gem 版本过老怎么办 A1: 请升级 gem $ sudo gem update --system Q2: 如何升级 Cocoapods 的版本？ A2: 升级 Cocoapods 的版本其实和安装是一样的 $ sudo gem install cocoapods Q3: 多个版本的 Cocoapods 如何卸载？ A3: 终端输入 $ gem list 如果你安装（也可能是升级导致）了多个版本的 Cocoapods，本例中如图，安装了 0.38.2 和 0.36.3 两个版本。想卸载其中的旧版本，0.36.3 $ sudo gem uninstall cocoapods 选择 1，更低的版本就被卸载掉了。 或者直接执行如下命令，老版本的都都被卸载了。 $ sudo gem clean Q4: 我怎么搜索不到某个第三方库的最新版本？ A4：可能是你的 Cocoapods 的版本低或者你本地的依赖库 tree 较旧所致。参见 Q2 和 pod setup 的使用。 Q5: 错误ERROR: While executing gem … (Gem::FilePermissionError) You don’t have write permissions for the /Library/Ruby/Gems/2.0.0 directory A5: 这个错误往往出现在安装 Cocoapods 或者删除某个版本的 Cocoapods 的情况下，简单粗暴就是修改权限 sudo chmod 777 /Library/Ruby/Gems/2.0.0 Q6: 为什么 Pods 导入成功了但是无法引用头文件？ A6: Cocoapods 把第三方库以多个 target 形式组成一个名为 Pods 的工程，编译为静态库，所以我们其实可以像引用系统框架一样来引入他们的头文件。 #import &lt;AFNetworking&gt; 如果一定要使用双引号的形式，那就设置目标项目 target 中的 User Header Search Paths，双击此选项，添加一个 ${SRCROOT}的键，值设定为recursive，这样就可以递归搜索全部目录。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[禅与Objective-C编程艺术-2]]></title>
      <url>%2F2015%2F08%2F02%2F2015-07-31-Zen-OC-Art-2%2F</url>
      <content type="text"><![CDATA[编程和「禅」有关系吗?Zen and the Art of the Objective-C Craftsmanship译文兼笔记本章包含规范：类名 类名类名前应该加上三个大写字母（两个字母为 Apple 的类保留）作为前缀，这个规范虽然看起来有点奇怪，但是可以减少 Objective-C 没有命名空间带来的不便。 有些开发者在定义 Model 对象时不遵循这个规范（尤其对于 Core Data 对象，更应该遵循这个规范），在定义 Core Data 对象时候我们建议严格遵循这个规范，因为你可以最后将你的 Managed Object Model（托管对象）和其他第三方库的 MOMs 合并。 可能你已经注意到了，本书中类名（不止类名）前缀是ZOC。 在你给类命名的时候还有一个命名规范：创建子类时，你应该把说明性部分放在类前缀和父类名之间。例如： 有个类名叫ZOCNetworkClient，子类名是ZOCTwitterNetworkClient（注意 “Twitter” 在”ZOC” 和”NetworkClient”之间）；遵循相同规范，一个UIViewController的子类应该是ZOCTimelineViewController。 Initializer 与 dealloc比较推荐的代码组织方式是：dealloc方法放在实现文件的最前面（直接在@synthesize和@dynamic语句之后），init应该直接放在dealloc之后。要是有多个初始化方法，预设初始化方法(designated initializer)应该放在第一个，接下来写次要初始化方法(secondary initializers )。 现在有了ARC，几乎不用实现dealloc方法了，但是把dealloc和init方法写的近点，从逻辑上来看可以强调他们的成对关系。通常在init方法中做什么了，在dealloc中都要做对应的销毁处理。 init方法的结构应该是这样的： - (instancetype)init&#123; self = [super init]; // call the designated initializer if (self) &#123; // Custom initialization &#125; return self;&#125; 为什么我们要把[super init]的返回值赋给self，如果不这么做会怎么样，这是个挺有意思的话题。 到退一步说，我们经常写类似[[NSObject alloc] init]这样的语句，逐渐忽略了alloc和init的区别。一个 Objective-C 的特性叫做两步创建。这就意味着分配内存和初始化是两个分开的步骤，因此就需要调用两个不通的方法：alloc和init. -alloc表示为对象分配内存空间。这个过程包括从应用的虚拟内存中为对象分配足够的内存，写入isa指针，初始化retain计数，并把所有实例变量的初值都设为零 -init表示初始化对象，这就意味着把对象转换成可用状态。这通常是指把恰当的初值赋给对象的实例变量。 alloc方法会返回一个未初始化的合法实例对象。每条发送给这个实例的消息都相当于是在调用objc_msgSend()方法，alloc返回对象的指针就指向那个叫做self的参数；这样self就可以调用所有方法了。 为了包含两步创建，通常情况下一个新创建的实例调用的第一个方法都应该是一个init方法。注意在NSObject的init实现中，什么都没做，只是返回了self而已。 init还有一个重要约定：在调用初始化方法失败的时候init方法会返回nil;初始化可以有很多失败的原因，比如输入的格式有错误，或者必要的对象初始化失败。 这就是为什么我为什么总是调用self = [super init]，如果你的父类因为某种原因无法初始化自身，你必须假设自己正处于这种状况下，所以在你的实现中不要还继续去使用初始化返回的nil。如果你没这样做你会得到一个不可用对象，此对象的行为是无法预测的，最终会导致你的 App 崩溃。 重新给self赋值也可以用来让init方法返回不同实例。例子就是 类簇 或者一些返回相同不可变实例对象的 Cocoa 类。 Designated 和 Secondary 初始化方法Objective-C 有 designated 初始化方法和 secondary 初始化方法的概念。 designated 初始化方法要传入所有参数，如果在调用 designated 初始化方法时仅提供一个或者多个默认参数，那么这种初始化方法就叫做 secondary 初始化方法。 @implementation ZOCEvent- (instancetype)initWithTitle:(NSString *)title date:(NSDate *)date location:(CLLocation *)location&#123; self = [super init]; if (self) &#123; _title = title; _date = date; _location = location; &#125; return self;&#125;- (instancetype)initWithTitle:(NSString *)title date:(NSDate *)date&#123; return [self initWithTitle:title date:date location:nil];&#125;- (instancetype)initWithTitle:(NSString *)title&#123; return [self initWithTitle:title date:[NSDate date] location:nil];&#125;@end 上面例子里的initWithTitle:date:location:就是 designated 初始化方法，另外两个是 secondary 初始化方法，因为他们只是调用了这个类里已经实现过了的 designated 初始化方法。 Designated 初始化方法一个类通常有且只有一个 designated 初始化方法，其他的初始化方法都是在调用这个 designated 初始化方法（虽然还是有一种例外情况），这种例外情况并没有要求调用那个初始化函数。 在继承中任何调用 designated 初始化方法都是合法的，而且在继承中得保证所有的 designated 初始化方法都是从先祖（通常是NSObject）到你的类这样，自上而下调用的。 实际上就是说第一个执行初始化代码的是最高级的先祖，然后才轮到继承的类；继承的所有的类都有资格去执行他们特定的初始化代码。总而言之，在开始做实际工作之前你从父类继承的所有东西都是已经是可用的状态。虽然这个状态并不明确，但是所有 Apple 的框架中的类都遵循这个原则，所以你的类也要这样做。 当定义一个新的类时，有三种不同的方法： 第一种办法最简单：你不需要添加任何额外的初始化逻辑，你只需要按照父类的 designated 初始化方法来做。 第二种：当你希望给 designated 初始化方法加入一些其他的初始化逻辑时，你可以重载它。你只需要重载父类的 designated 初始化方法并且保证实现调用了父类的重载方法。 一个经典案例就是当你创建一个 UIViewController的子类时重载initWithNibName:bundle:方法： @implementation ZOCViewController- (id)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil&#123; // call to the superclass designated initializer self = [super initWithNibName:nibNameOrNil bundle:nibBundleOrNil]; if (self) &#123; // Custom initialization &#125; return self;&#125;@end 在UIViewController的子类中重载init方法会报错，因为这种情况下会尝试调用initWithNib:bundle来初始化你的类，你写在init方法里面的实现并不会被调用。这还违背了调用任何 designated 初始化方法的规则。 第三种：如果你想写一个自定义的 designated 初始化函数的时候，你要遵循三点： 很多程序员都忽略了后两步，这不是细心不细心的问题，忽略后两步本身就是违反了框架规范，还会导致一些未知 bug。 看下正确的实现： @implementation ZOCNewsViewController- (id)initWithNews:(ZOCNews *)news&#123; // call to the immediate superclass's designated initializer self = [super initWithNibName:nil bundle:nil]; if (self) &#123; _news = news; &#125; return self;&#125;// Override the immediate superclass's designated initializer- (id)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil&#123; // call the new designated initializer return [self initWithNews:nil];&#125;@end 如果你没重载initWithNibName:bundle方法，正常就只会用initWithNibName:bundle来初始化你的类（这是完全合法的），initWithNews这个方法就永远不会被调用。正是因为你特定的初始化逻辑代码部分并没有被调用，这就导致初始化流程不正确。 即使可以推断那个方法是 designated 初始化方法，但是最好也要明确得说明这是一个 designated 初始化方法（以后你自己或者其他程序员在改这份代码的时候会谢谢你的）。你可以用两种办法（并不相互排斥）： 一种是你在文档中就明确出哪一个是 designated 初始化方法，但是你最好是用如下编译器指令来表明你的意图。 __attribute__((objc_designated_initializer)) 如果你新的 designated 初始化方法并没有调用父类的 designated 初始化方法，用了这条指令编译器就会提示一条警告。 然而，当没有调用类的 designated 初始化方法（并且提供必要参数）而调用其他父类中的 designated 方法时，会导致当前类处于一个不可用的状态。参考之前的例子，实例化一个ZOCNewsViewController来展示新闻，但是实例化结束后并没有新闻，这就没意义了。这种情况你可以强制只调用一个特殊的 designated 初始化方法，让其他初始化方法都失效。可以用如下编译器指令来修饰这个方法，当你尝试调用这个方法的时候编译器就会报错。 __attribute__((unavailable("Invoke the designated initializer"))) 这是上面案例相关实现的头文件（注意用宏来避免代码太罗嗦） @interface ZOCNewsViewController : UIViewController- (instancetype)initWithNews:(ZOCNews *)news ZOC_DESIGNATED_INITIALIZER;- (instancetype)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil ZOC_UNAVAILABLE_INSTEAD(initWithNews:);- (instancetype)init ZOC_UNAVAILABLE_INSTEAD(initWithNews:);@end 上述代码要表达的是：永远别从 designated 初始化方法中调用 secondary （如果 secondary 初始化方法遵循规范，他会调用 designated 初始化方法）。如果在 designated 初始化方法中调用了 secondary 初始化方法，很容易会调用到子类重写过的初始化方法，然后就会导致无限递归。 不过一个例外是如果一个对象遵循NSCoding协议，他就用initWithCoder:方法初始化。 我们需要看父类是否遵循NSCoding协议来区别对待。 遵循NSCoding协议的话，直接调用super initWithCoder:可能会和 designated 初始化方法有些共享代码。解决这个问题的一个好办法就是写在一个私有方法里（比如p_commonInit）。 当父类不遵循NSCoding协议，建议把initWithCoder:当做 secondary 初始化方法来看，因此就要调用 self的 designated 初始化方法。注意，这跟 Apple 在 Archives and Serializations Programming Guide 中建议的如下规范相违背： the object should first invoke its superclass’s designated initializer to initialize inherited state 对象应该先调用父类的 designated 初始化方法来初始化继承状态 依据此原则，如果你的类不是NSObject的直接子类，这样做就会造成未知隐患。 次要初始化方法就如上面一段所说的，secondary 初始化方法是一种非常便捷为 designated 初始化方法提供默认值或默认动作的方法。也就是说，在 secondary 初始化方法里不应该有任何强制的出初始化方法，而且要假设这个方法永远不被直接调用。重申一次，我们得保证直接被调用的是 designated 初始化方法。 这就意味着，你的 designated 初始化方法应该是调用其他 secondary 初始化方法或者你self的 designated 初始化方法。有时候可能不小心了，写成了super，这样就会导致并未遵循上述的顺序来初始化（在这种特殊的情况里，跳过了当前类的初始化）。 参考 https://developer.apple.com/library/ios/Documentation/General/Conceptual/DevPedia-CocoaCore/ObjectCreation.html https://developer.apple.com/library/ios/documentation/General/Conceptual/CocoaEncyclopedia/Initialization/Initialization.html https://developer.apple.com/library/ios/Documentation/General/Conceptual/DevPedia-CocoaCore/MultipleInitializers.html https://blog.twitter.com/2014/how-to-objective-c-initializer-patterns instancetype我们总是忘记 Cocoa 是充满各种规范的，这些规范可以让编译器变的更聪明一些。无论编译器是否碰到alloc或者init方法，他都知道这两个方法返回的类型都是id，那些方法总是返回接受到类的实例对象。因此，这样就为编译器进行类型检查提供了可能（比如，检查方法返回类型是否合法）。Clang 的这个好处来自于 related result type，意味着： messages sent to one of alloc and init methods will have the same static type as the instance of the receiver class alloc 和 init 方法会检查发送来的消息返回的静态类型和接受到的类实例类型是否相同 想获得更多关于自动定义返回类型的相关规范清参考 Clang Language Extensions guide 中的 appropriate section。 用instancetype关键字作为返回类型可以让相关返回结果类型更加明确，在一些工厂方法或者构造器方法这些场景下很有用。这可以提醒编译器检查类型是否正确，更重要的是，子类的类型是否正确也会检查。 @interface ZOCPerson+ (instancetype)personWithName:(NSString *)name;@end 尽管如此，根据 clang 规定，编译器可以把id升级到instancetype。在alloc或者init中，我们强烈推荐对所有返回类实例的实例化方法和类方法，都用instancetype作为返回类型。 在你所有的 API 中，你最应该建立起一种习惯来保持统一性（可能还会增加可读性）。此外，通过对代码的小调整可以增加你代码的可读性：简单浏览一下你的代码就能分辨出哪些方法是返回当前类的实例。以后你会感谢在意过这些细节。 参考 http://tewha.net/2013/02/why-you-should-use-instancetype-instead-of-id/ http://tewha.net/2013/01/when-is-id-promoted-to-instancetype/ http://clang.llvm.org/docs/LanguageExtensions.html#related-result-types http://nshipster.com/instancetype/ ​ 初始化模式类簇（Class cluster）在 Apple 的文档中对类簇的描述是这样： an architecture that groups a number of private, concrete subclasses under a public, abstract superclass. 类簇是，在一个公共的、抽象的父类下，一组私有的、具体的子类架构。 如果这个描述你听着耳熟，那就对了。类簇其实就是 Apple 语言体系中的抽象工厂设计模式。 类簇的主旨很简单：一个抽象的父类，在初初始化过程中处理信息，经常为初始化方法提供参数或者从环境中获取，来实现逻辑并初始化一个具体的子类。这个”公共面向（public facing）”的类应该对自己的子类有所掌控，并返回最优类型的私有子类。 这个模式非常有用，因为这让调用者省去了繁杂的初始化逻辑，只需要知道要通信对象的接口，不用关心具体的内部实现。 Apple 的框架中广泛使用了类簇；一些值得注意的例子有NSNumber，它可以根据提供的数字类型（Integer,Float,etc…）来返回对应的子类，还有NSArray会根据最优存储策略返回最适合的具体子类。 这个模式的优点在于，调用者可以完全不用关心子类；实际上可以用来设计一个库，用来切换实际返回的类，同时还不必暴露任何实现的细节，因为他们都遵循抽象父类的方法。 依我们的经验来看用类簇可以对移除一堆条件语句很有帮助。 一个典型的例子就是当你在 iPhone 和 iPad 中都有 UIViewController 的子类，但是在不同的设备上有不同的表现。 基础的实现办法是在方法中用一些条件语句来检查设备，然后执行不同的逻辑。虽然开始的时候这部分条件逻辑语句只有几行，但是随着要处理的步骤增多代码也就越来越冗杂了。 一个更好的实现设计是创建一个抽象且通用的 view controller 包含所有共享逻辑，并对应不同设备有两个特别的子类。 这个通用的 view controller 会检查当前设备的特性并根据这一特性返回对应的子类。 @implementation ZOCKintsugiPhotoViewController- (id)initWithPhotos:(NSArray *)photos&#123; if ([self isMemberOfClass:ZOCKintsugiPhotoViewController.class]) &#123; self = nil; if ([UIDevice isPad]) &#123; self = [[ZOCKintsugiPhotoViewController-iPad alloc] initWithPhotos:photos]; &#125; else &#123; self = [[ZOCKintsugiPhotoViewController-iPhone alloc] initWithPhotos:photos]; &#125; return self; &#125; return [super initWithNibName:nil bundle:nil];&#125;@end 上述的代码例子展示如何创建一个类簇。首先下述语句防止子类重载初始化方法，避免了无限递归。 [self isMemberOfClass:ZOCKintsugiPhotoViewController.class] 当下述代码被调用时，上述检测会为 true，self = nil是用来移除所有对ZOCKintsugiPhotoViewController 实例的引用，这样他就会被释放，按照逻辑来决定初始化哪个子类。 [[ZOCKintsugiPhotoViewController alloc] initWithPhotos:photos] 我们假设在 iPhone 上跑这段代码ZOCKintsugiPhotoViewController-iPhone没有重载initWithPhotos:；这时候，执行 self = [[ZOCKintsugiPhotoViewController-iPhone alloc] initWithPhotos:photos]; ZOCKintsugiPhotoViewController将会被调用，并当第一次检查时ZOCKintsugiPhotoViewController 的类检查将会是 false，那么就会直接调用 return [super initWithNibName:nil bundle:nil]; 这样就会按照之前重点讲过的初始化方法来继续进行初始化。 单例(Singleton)能不用就别用单例，用依赖注入来代替。 然而，一定要用单例用该用一个安全线程模式来创建共享实例。对于 GCD，可以用dispatch_once()函数。 + (instancetype)sharedInstance&#123; static id sharedInstance = nil; static dispatch_once_t onceToken = 0; dispatch_once(&amp;onceToken, ^&#123; sharedInstance = [[self alloc] init]; &#125;); return sharedInstance;&#125; 用同步的dispatch_once()来代替下方旧的老办法： + (instancetype)sharedInstance&#123; static id sharedInstance; @synchronized(self) &#123; if (sharedInstance == nil) &#123; sharedInstance = [[MyClass alloc] init]; &#125; &#125; return sharedInstance;&#125; 相比上述例子dispatch_once()的优势在于更快，语意上也更明确，因为dispatch_once()的总体含义就是”执行且只执行一次”，正好和我们做的一样。这样同时可以避免possible and sometimes prolific crashes。 使用单例对象的经典例子是 GPS 和设备加速器。尽管单例对象可以子类化，但是在这些情况下也是挺好用的。这个接口应该说明，给出的类应该用单例模式。因此，通常一个单独的公共sharedInstance类方法就够了，并且只读的属性也应该暴露。 在代码或者层之间，把单例用作一个对象容器来共享是很傻很糟糕的，是一个不好的设计。 属性(Properties)属性应该尽量使用描述性命名，避免缩写，而且要用以小写字母开头的驼峰式。幸运的是我们选择的工具可以帮我们自动补全(呃…几乎是所有的，嗯，我说的就是 Xcode 的 Derived Data)，所以没理由去节省一些字符，尽可能在你的源码里表达更多的信息。 例如: NSString *text; 不要这样: NSString* text;NSString * text; （注意：这个习惯和常量不同。这确实是为常用和可读性考虑。C++ 开发者更喜欢把变量的类型从名字中分离出来，作为一个纯粹的类型就应该是NSString*（这是对于从堆中分配的对象，C++ 应该是从栈上分配对象）。那就用该用NSString* text格式来写。） 用属性的 auto-synthesize，别用手写的@synthesize，除非你的属性只是 protocol 的一部分而不是一个具体的类。如果 Xcode 能自动同步变量，那就让 Xcode 做。否则你就是放弃了 Xcode 的优势来维护一段很冗余的代码。 除了 init和dealloc方法，应该经常使用 set 和 get 方法访问属性。通常来说，用属性来访问当前作用域以外的的代码增加了一些视觉上的便利，但是也会存在副作用。 用 setter 的好处有： 使用 setter 会遵循内存管理的定义（strong, weak, copy 等等…）。这在 ARC 之前就挺重要的，有了 ARC 之后依旧也很重要。举个例子，copy的语意：每次你使用 setter 传入的值都是一个副本，没有任何额外的操作。 KVO 通知(willChangeValueForKey, didChangeValueForKey) 会被自动执行。 更容易debug：你可以在属性声明上设置一个断点，setter/getter 每次执行时断点就会生效，或者你也可以在自定义的 setter/getter 设置断点 在设定值的时候可以增加额外的逻辑 用 getter 的好处： 扩展性和适应性更好（比如：属性是自动生成的） 允许子类化 更容易 debug （比如：可以在 getter 中打一个断点来看看到底是谁调用了这个特殊的getter） 让目的更清晰明确：在访问一个 ivar _anIvar时实际上你是在访问self-&gt;_anIvar。这可能会导致一些问题，比如，在一个 block 内访问 iVar（尽管你并没有明确的看到self关键字，但是你还是 retain 了 self） 自动产生 KVO 通知 发消息的额外性能开销很低，大部分情况下是可以忽略不计的。更多关于属性的性能问题介绍可以参考Should I Use a Property or an Instance Variable? Init 和 Dealloc但是有个一个例外:在init(和其他初始化方法)中你千万不能用 setter (或者 getter)，你应该直接访问实例变量。这是为了防止在子类化的时候出现问题：实际上一个子类可以重载 setter (或者 getter)取调用其他方法，访问属性或者 iVar 时他们可能并未完全初始化。要记住，只有在 init 返回时，一个对象才被认为是完全初始化完成状态。在 dealloc 方法(在 dealloc方法中对象可能在一个不确定的状态)这些也是一样的。 下述文档中也都反复陈述很多次了： Advanced Memory Management Programming Guide under the self-explanatory section “Don’t Use Accessor Methods in Initializer Methods and dealloc”; Migrating to Modern Objective-C at WWDC 2012 at slide 27; in a pull request form Dave DeLong’s. 此外，在 init 中使用 setter 不会很好的执行 UIAppearence代理(更多信息参见 UIAppearance for Custom Views )。 点语法当在使用 setter/getter 时更倾向于用点语法，在设置属性时通常都应该用点语法。 例如: view.backgroundColor = [UIColor orangeColor];[UIApplication sharedApplication].delegate; 不要: [view setBackgroundColor:[UIColor orangeColor]];UIApplication.sharedApplication.delegate; 使用点语法会让表达更清晰，并且帮助区分是在访问属性还是在调用方法。 属性声明按照如下格式来声明属性 @property (nonatomic, readwrite, copy) NSString *name; 属性参数应该按照如下顺序:原子性，是否可读写，内存管理。这样写你在修改属性的时候就能很容易的找到位置并且看起来更方便。 除非特殊必要，应该都要使用nonatomic，在 iOS 中，atomic锁会非常影响性能。 属性可以存储一个 block，想让其生命周期贯穿定义域，应该用copy来修饰(block 创建时在栈中，用copy可以让其拷贝到堆中)。 为了实现一个共有的 getter 和一个私有的 setter，你应该用readonly来声明属性，并在类扩展中重新将其声明为readwrite： @interface MyClass : NSObject@property (nonatomic, readonly) NSObject *object@end@implementation MyClass ()@property (nonatomic, readwrite, strong) NSObject *object@end 如果一个Bool类型的属性的命名表达了描述性含义，这个属性可以省略”is”，但是在 get 方法访问时依照惯例还是要加上特定的”is”，例如： @property (assign, getter=isEditable) BOOL editable; 正文和举例引用自Cocoa Naming Guidelines. 在实现文件中就不必再用@synthesize，Xcode 已经帮你加好了。 私有属性私有属性应该在类实现文件中的类扩展(class extensions，即没有名字的 categories)中声明。除非要扩展其他的类，否则不要使用有名称的 categories (例如，ZOCPrivate)。 For example: @interface ZOCViewController ()@property (nonatomic, strong) UIView *bannerView;@end 可变对象潜在可以被可变对象(例如，NSString，NSArray，NSURLRequest)赋值的任何属性，其内存管理类型必须为copy。这是为了保证封装的安全，同时避免在对象不知情的情况下，修改了属性的值。 在公共接口中也应该避免暴露可变对象，因为这个类的使用者就可以改变这个类的内部描述同时破坏了封装。可以提供一个只读属性，返回对象的不可变副本： /* .h */@property (nonatomic, readonly) NSArray *elements/* .m */- (NSArray *)elements &#123; return [self.mutableElements copy];&#125; 懒加载实例化一个对象是很消耗资源的，很多情况下在实例化的过程中包括了一些设置，但是又不想弄乱调用的方法，并且这种设置只需要一次。 在这种情况下，可以选择重载属性 getter 来懒初始化，以此来代替在初始化方法中实例化对象。通常这类操作的案例如下： - (NSDateFormatter *)dateFormatter &#123; if (!_dateFormatter) &#123; _dateFormatter = [[NSDateFormatter alloc] init]; NSLocale *enUSPOSIXLocale = [[NSLocale alloc] initWithLocaleIdentifier:@"en_US_POSIX"]; [dateFormatter setLocale:enUSPOSIXLocale]; [dateFormatter setDateFormat:@"yyyy-MM-dd'T'HH:mm:ss.SSSSS"]; &#125; return _dateFormatter;&#125; 尽管这样在某些特定情况下挺好的，但是在用之前还是要深思熟虑的，实际上这中行为是应该规避的。下列是使用懒加载的一些反对论点： getter 理论上是没有副作用的。从另一个角度看你不应该觉得 getter 会实例化一个对象或者觉得这是产生副作用了。实际上，尝试去调用一个没有返回值的 getter 编译器会警告：“getter 不会产生副作用；”。 在首次访问时把初始化的损耗作为副作用移除了，这会导致性能优化问题(也很难进行测试)。 初始化的时刻可能是不确定的：例如，你预计这个属性是被某个方法首次访问，但是你后来改变了类的实现，导致访问器被调用的时刻比你预期的要早。这会导致很多问题，尤其是如果初始化逻辑依赖于该类的其他状态时，那结果就不同了。总而言之最好明确依赖关系。 这种行为对 KVO 不友好。如果 getter 改变了引用它应该通过 KVO 通知来通知改变，当访问 getter 就会得到一个改变通知这种方法就挺蹩脚的。 方法参数断言你的方法可能要求一些参数来满足特定的条件(比如不能为 nil)；这种状况下最好用NSParameterAssert()来判断条件是否成立或者抛出异常。 私有方法永远不要在你的私有方法前加上下划线_，这个前缀是 Apple 保有的，这样做会让你面临重载 Apple 已有私有方法的险境。 相等当你要实现相等比较时，要记住这个约定：你要同时实现isEqual和hash方法。如果通过isEqual认为两个对象是相等的，hash方法必须返回相同值，但是如果hash方法返回相同值，并不能认为两个对象是等值的。 这个约定归根究底就是，在对象存储在集合(例如，NSDictionary和NSSet在底层使用 hash 表的数据结构)中时，如何查找他们。 @implementation ZOCPerson- (BOOL)isEqual:(id)object &#123; if (self == object) &#123; return YES; &#125; if (![object isKindOfClass:[ZOCPerson class]]) &#123; return NO; &#125; // check objects properties (name and birthday) for equality ... return propertiesMatch;&#125;- (NSUInteger)hash &#123; return [self.name hash] ^ [self.birthday hash];&#125;@end 一定要注意的是 hash 方法一定不能返回一个常量。这是一个典型的错误并且会导致很严重的问题，因为当 hash 方法返回值用作 hash 表的 key 时，会导致 hash 表的100%碰撞。 你通常应该按照isEqualTo&lt;#class-name-without-prefix#&gt;这种格式来实现是否相等的检测方法。通常应该优先调用这个验证相等方法来避免上述的类型检测方法。 一个完整的 isEqueal* 方法应该是如下样式的： - (BOOL)isEqual:(id)object &#123; if (self == object) &#123; return YES; &#125; if (![object isKindOfClass:[ZOCPerson class]]) &#123; return NO; &#125; return [self isEqualToPerson:(ZOCPerson *)object];&#125;- (BOOL)isEqualToPerson:(Person *)person &#123; if (!person) &#123; return NO; &#125; BOOL namesMatch = (!self.name &amp;&amp; !person.name) || [self.name isEqualToString:person.name]; BOOL birthdaysMatch = (!self.birthday &amp;&amp; !person.birthday) || [self.birthday isEqualToDate:person.birthday]; return haveEqualNames &amp;&amp; haveEqualBirthdays;&#125; 如果一个给定的对象实例被加入到一个容器对象(如，NSArray，NSSet或者NSDictionary)，其 hash计算结果应该是确定的，否则加入容器对象的行为将无法定义(所有容器对象都是用对象的 hash 值来进行查找行为的，或者实现一些特殊属性，比如包含对象的唯一性检测)。也就是说，最好只用不可变属性来计算 hash 值，或者，最好保证对象是不可变的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Typora:从此请叫我键盘侠]]></title>
      <url>%2F2015%2F07%2F27%2F2015-07-27-Markdown-Typora%2F</url>
      <content type="text"><![CDATA[Typora所见即所得的Markdown编辑器 MarkdownMarkdown 作为一种标记型语言，从来不是为了取代 HTML 而存在的。其易读易写的宗旨是我持续使用这门标记语法的根本动力。当为知笔记支持 Markdown 语法之后，Markdown 就成为了我记笔记最常用的方法。最大的优点在于尽量减少鼠标去点击编辑栏添加各种样式的烦恼，大大提升书写效率。 当然，GitHub 的 README.md 对 Markdown 的推广功不可没。 EditorMac 下有多款 Markdown 编辑器。目前常用的有两款，一个是 Mou，另一个则是 Haroopad 。两款编辑器都是左右布局，左侧显示编辑区域，右侧显示预览效果。虽然脖子不必跟着左右晃动，但是眼睛时常左顾右撇让我无法专注于书写内容。而且作为一个懒人，总是梦想着能有快捷键能快捷输入一些略微复杂的符号语法。 直到我发现了 Typora 。 TyporaTypora 的特性在于，无论是手动输入符号，还是快捷键插入，亦或是 MenuBar 手动点击，都可以实现内容效果的实时预览。 Typora 的 MenuBar 提供了如下功能： 在 Paragraph 选项中，你可以找到与段落相关的常用标记 在 Format 选项中，你可以找到关于格式的相关标记 段落例如，当用户按下 command + 1 时，接下来键入的文本将会成为一级标题。最关键的是，只要光标所在的当前文本段按下对应字体样式的快捷键，就会自动调整。 表格按下command + T会弹出一个选择行和列的对话框 选择好行和列就会出现之前需要较多符号租成的 table 了。 选中 table 会出现编辑行数和列数的选项，以及文本位置和删除表格的按钮。 代码块按下command + option + C将会出现代码块输入框。键入代码后可以在下方选择代码语言以获得最佳的视觉效果。 公式按下command + option + B会出现公式输入框，例如要显示如下公式。 f(x)=x^&#123;x^x&#125; 图片 支持本地拖拽图片，快捷键command + option + I Summary当有需求时正好被满足，这无疑是一件极为令人开心的事儿。Typora 对于我来说无异于雪中送炭。 喜欢这类编辑模式的用户一定不要错过。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[禅与Objective-C编程艺术-1]]></title>
      <url>%2F2015%2F07%2F20%2F2015-07-20-Zen-OC-Art-1%2F</url>
      <content type="text"><![CDATA[编程和「禅」有关系吗?Zen and the Art of the Objective-C Craftsmanship译文兼笔记本章包含规范：条件语句、Case 语句、命名 条件语句(Conditionals)虽然条件语句体可以不写在大括号里（比如就一行），但是为了避免错误还是应该把条件语句体写在大括号内部。比如不写在括号里时，插入的第二行代码会误以为是条件语句体的一部分。还有个更致命的危险就是，当仅有的一句 if 语句被注释掉时，无意之间下一行代码就成为 if 语句的一部分了。 推荐: if (!error) &#123; return success;&#125; 不推荐: if (!error) return success; 或 if (!error) return success; 2014年二月 苹果的SSL/TLS的实现中就发现了众所周知的goto fail错误。 错误原因是在 if 条件后重复出现了 goto 语句，把 if 分支写在括号里就能避免这类问题。 代码如下 static OSStatus SSLVerifySignedServerKeyExchange(SSLContext *ctx, bool isRsa, SSLBuffer signedParams, uint8_t *signature, UInt16 signatureLen) &#123; OSStatus err; ... if ((err = SSLHashSHA1.update(&amp;hashCtx, &amp;serverRandom)) != 0) goto fail; if ((err = SSLHashSHA1.update(&amp;hashCtx, &amp;signedParams)) != 0) goto fail; goto fail; if ((err = SSLHashSHA1.final(&amp;hashCtx, &amp;hashOut)) != 0) goto fail; ... fail: SSLFreeBuffer(&amp;signedHashes); SSLFreeBuffer(&amp;hashCtx); return err; &#125; 很明显，两行连续的 goto fail; 没有写在括号里。我们肯定不想出现上述类似的错误。 还有在其他条件语句中也应保持这种代码风格，便于检查。 尤达表达式尽量别用尤达表达式。尤达表达式就是用常量去和变量比较，而不是用变量跟常量比较。比如正常表达是「天空是不是蓝色的」或者「这个人是不是高个子」，尤达表达式就会说成「蓝色是不是天空的颜色」或者「高个子是不是这个人的属性」。 推荐: if ([myValue isEqual:@42]) &#123; ... 不推荐: if ([@42 isEqual:myValue]) &#123; ... nil 和 BOOL 检查和尤达表达式类似，nil检查方式也是存在争议的。 一些 notous 库像这样检查对象是否为 nil: if (nil == myValue) &#123; ... 因为 nil 为常量的情况下，这种情况就很像尤达表达式，或许有人就会提出这种写法是错误的。其实很多程序员这么做的原因是为了避免调试困难，请看如下代码： if (myValue == nil) &#123; ... 如果不小心写成这样： if (myValue = nil) &#123; ... 这种表达是符合语法的，就算你是个经验丰富的程序员也很难能找出错误。但是如果把 nil 像变量一样放在左边这种错误就不会发生因为它不能被赋值。如果程序员用这种办法，就可以很容发现一些可能的原因，比反复检查写过的代码要好很多。 避免这些奇怪问题的办法，可以用感叹号来作为运算符。因为 nil 的意思就是 NO ，没必要在条件语句里把它跟其他值比较。还有千万不要直接去和 YSE 比较，因为 YES 的定义是 1 ，而 BOOL 是 8 bit 的，实际上是 char 类型。 推荐: if (someObject) &#123; ...if (![someObject boolValue]) &#123; ...if (!someObject) &#123; ... 不推荐: if (someObject == YES) &#123; ... // Wrongif (myRawValue == YES) &#123; ... // Never do this.if ([someObject boolValue] == NO) &#123; ... 这样也能提高文件的统一性和可读性。 黄金法则当写条件语句的时候，代码左侧留有空隙是让人愉悦的黄金法则。就是说，不要嵌套 if 语句。多写几个 return 没啥问题。这会避免cyclomatic complexity的增加并且让代码更加易读，因为方法的重要部分都未嵌套在分支内，你就可以很清楚的找到相关代码。 推荐: - (void)someMethod &#123; if (![someOther boolValue]) &#123; return; &#125; //Do something important&#125; 不推荐: - (void)someMethod &#123; if ([someOther boolValue]) &#123; //Do something important &#125;&#125; 复杂条件语句当在 if 分句中有一个复杂条件时，应该把它抽取出来赋值给一个 BOOL 变量，这样逻辑就会更清晰同时每个单独的条件语句的含义都很明确。 BOOL nameContainsSwift = [sessionName containsString:@"Swift"];BOOL isCurrentYear = [sessionDateCompontents year] == 2014;BOOL isSwiftSession = nameContainsSwift &amp;&amp; isCurrentYear;if (isSwiftSession) &#123; // Do something very cool&#125; 三目运算符三目运算符 ? 只应该用在让代码更清晰简洁的地方。单独的条件语句通常都应该是计算好值了的。对于条件语句来说，多个条件子句的计算会让代码更加难懂，或者可以把他们重构到实例变量里面。 推荐: result = a &gt; b ? x : y; 不推荐: result = a &gt; b ? x = c &gt; d ? c : d : y; 当三目运算的第二个参数( if 分支)返回的对象和条件语句中检查已存在的对象相同的时候，如下语法更优雅： 推荐: result = object ? : [self createObject]; 不推荐: result = object ? object : [self createObject]; 错误处理当方法返回一个错误参数的引用时，检查返回值，而非出错的变量 推荐: NSError *error = nil;if (![self trySomethingWithError:&amp;error]) &#123; // Handle Error&#125; 此外，一些苹果的 API 在请求成功的情况下会对 error 参数(如果非空)写入垃圾值（garbage values）,所以如果检查 error 的值可能会导致出错（甚至崩溃）。 Case 语句除非编译器强制要求，否则在 case 语句中不是必须写括号的。 要是一个 case 有多行，那就需要加上括号。 switch (condition) &#123; case 1: // ... break; case 2: &#123; // ... // Multi-line example using braces break; &#125; case 3: // ... break; default: // ... break;&#125; 有很多时候多个 case 中执行同一段代码，那就用上 fall-through了。fall-through 就是移除 case 的 break 语句然后让下面的 case 继续执行。 switch (condition) &#123; case 1: case 2: // code executed for values 1 and 2 break; default: // ... break;&#125; 当在 switch 中用枚举变量时，就不用非要写 default 了。例如： switch (menuType) &#123; case ZOCEnumNone: // ... break; case ZOCEnumValue1: // ... break; case ZOCEnumValue2: // ... break;&#125; 此外，为了避免使用默认的 case ，如果枚举增添了新的值，程序员就会立即收到一个警告： Enumeration value ‘ZOCEnumValue3’ not handled in switch. 枚举类型 ZOCEnumValue3 未被 switch 处理 枚举类型当使用 enum 时，建议用固定基础类型标准，因为它具备更强的类型检查和和代码补全能力。SDK 现在提供了一个宏来促进和鼓励使用固定基础类型- NS_ENUM() 例子: typedef NS_ENUM(NSUInteger, ZOCMachineState) &#123; ZOCMachineStateNone, ZOCMachineStateIdle, ZOCMachineStateRunning, ZOCMachineStatePaused&#125;; 命名惯例要尽可能的遵守苹果的命名规范，尤其是跟内存管理规则(NARC)相关的部分。 推荐使用详尽的、语意强的的方法名和变量名。 推荐: UIButton *settingsButton; 不推荐: UIButton *setBut; 常量常量的应该遵循驼峰命名法，为了语意清晰，应该使用相关的类名作为前缀。 推荐: static const NSTimeInterval ZOCSignInViewControllerFadeOutAnimationDuration = 0.4; 不推荐: static const NSTimeInterval fadeOutTime = 0.4; 字符串和数字应该尽量抽离常量，这样便于复用，而且在替换的时候很快捷，也不需要到处查找。常量应该用 static声明，除了特别明确的要用宏定义，否则就别用#define了。 推荐: static NSString * const ZOCCacheControllerDidClearCacheNotification = @"ZOCCacheControllerDidClearCacheNotification";static const CGFloat ZOCImageThumbnailHeight = 50.0f; 不推荐: #define CompanyName @"Apple Inc."#define magicNumber 42 在interface文件中，暴露在外部的常量应该遵循如下写法： extern NSString *const ZOCCacheControllerDidClearCacheNotification; 在实现文件中，实现对之前常量的定义。 对于公共常量需要加上一个命名空间前缀。尽管在实现文件中常量也会有一些其他写法，那么也没必要一定遵循这个规则。 方法对于方法签名，在方法类型(-/+)后应该有一个空格。方法段落之间也应该有一个空格（符合 Apple 的规范）。在参数名之前应该有一个描述性关键字。 要谨慎使用 and 命名，它不应该用作来表示有多个参数，比如下面initWithWidth:height:的例子。 推荐: - (void)setExampleText:(NSString *)text image:(UIImage *)image;- (void)sendAction:(SEL)aSelector to:(id)anObject forAllCells:(BOOL)flag;- (id)viewWithTag:(NSInteger)tag;- (instancetype)initWithWidth:(CGFloat)width height:(CGFloat)height; 不推荐: - (void)setT:(NSString *)text i:(UIImage *)image;- (void)sendAction:(SEL)aSelector :(id)anObject :(BOOL)flag;- (id)taggedView:(NSInteger)tag;- (instancetype)initWithWidth:(CGFloat)width andHeight:(CGFloat)height;- (instancetype)initWith:(int)width and:(int)height; // Never do this. 字面量创建任何不可变的实例对象时，应该用NSString, NSDictionary, NSArray, 和 NSNumber 这些对象。特别注意的是别在NSArray和NSDictionary中放入nil，这样会导致崩溃。 例如: NSArray *names = @[@"Brian", @"Matt", @"Chris", @"Alex", @"Steve", @"Paul"];NSDictionary *productManagers = @&#123;@"iPhone" : @"Kate", @"iPad" : @"Kamal", @"Mobile Web" : @"Bill"&#125;;NSNumber *shouldUseLiterals = @YES;NSNumber *buildingZIPCode = @10018; 别这样做: NSArray *names = [NSArray arrayWithObjects:@"Brian", @"Matt", @"Chris", @"Alex", @"Steve", @"Paul", nil];NSDictionary *productManagers = [NSDictionary dictionaryWithObjectsAndKeys: @"Kate", @"iPhone", @"Kamal", @"iPad", @"Bill", @"Mobile Web", nil];NSNumber *shouldUseLiterals = [NSNumber numberWithBool:YES];NSNumber *buildingZIPCode = [NSNumber numberWithInteger:10018]; 如果需要用到上述这些类的可变副本，应该用如NSMutableArray, NSMutableString等等这些更为准确的类。 下面的情况 不要出现: NSMutableArray *aMutableArray = [@[] mutableCopy]; 上述写法存在执行效率和可读性的双重问题。 在执行效率上，创建一个立即销毁的不可变变量是没必要的。虽然这样做不太会拖慢你的 App （除非很频繁调用该方法），但是没必要为了少打几个字儿就这么写。 考虑到可读性，有两个问题： 一，当你浏览代码的时候看到@[]第一时间你会想到关于NSArray这个类的实例，这种情况你就得停下来思考一下这是怎么回事。 二，一些新手以他们的阅历，就会对可变对象与不可变对象之间的矛盾感到疑惑。他/她可能对创建一个可变副本不是很熟悉（当然也不是说这部分知识不重要）。 当然，这都不是什么绝对性的错误，更多是在说可用性（包括可读性）方面的问题。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[在GitHub上搭建基于Hexo的静态Blog]]></title>
      <url>%2F2015%2F05%2F18%2F2015-05-18-Hexo-GitHub-Disqus%2F</url>
      <content type="text"><![CDATA[如果一只鸟在周围没有任何生物的情况下唱了一首歌 后来她死了这首歌存在吗?不管是否有人看 我终究还是要写的 EnvironmentRequired OS X HomeBrew Node.js Git Hexo GitHub account Disqus account 或多说账户 Optional Swiftype account 百度统计账户 域名 DNSPod account InstallationHomeBrew打开你的 Terminal 或 iTerm ，输入 $ ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; Git &amp; Node.jsTerminal 输入 $ brew install git 安装完成后再输入 $ brew install node npm 会跟 node 一同装好 HexoTerminal 输入 $ npm install -g hexo-cli 至此安装完毕 SetupInitialize以创建于 ~/Desktop/Joe 为例 $ hexo init ~/Desktop/Joe $ cd ~/Desktop/Joe $ npm install 项目结构如下： . ├── _config.yml ├── package.json ├── scaffolds ├── scripts ├── source | ├── _drafts | └── _posts └── themes Configuration yaml 语法严谨，千万不要忘记空格! 打开 ~/Desktop/Joe/_config.yml 填入以下内容 # 博客名称 title: Joe&apos;s Room # 描述 description: 井蛙语海 夏虫语冰 # 作者 author: Joe # 博客语言 language: zh-Hans # 博客地址 url: http://joehill.me #主题名称 theme: next # 多说 duoshuo_shortname: your-duoshuo-shortname # Disqus 帐号(多说 Disqus 二选一) disqus_shortname: your-disqus-shortname ##增加以下内容## # 社交链接，将在侧栏中显示 social: GitHub: your-github-url Twitter: your-twitter-url Weibo: your-weibo-url DouBan: your-douban-url ZhiHu: your-zhihu-url # ID 为百度统计提供脚本中 hm.js? 后字符串，非百度统计帐号 baidu_analytics: 41f2ac3e7c22ef73312321800c11b369 # 站点起始时间 since: 2011 # swiftype 站内搜索 swiftype_key: EKNBn-kdy2Bpu7SQLsGp # Creative Commons 4.0 International License. # http://creativecommons.org/ # Available: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero creative_commons: by-nc-sa Theme本文推荐使用 next 主题，下文仅以 next 为例。 Installation$ cd ~/Desktop/Joe $ git clone https://github.com/iissnan/hexo-theme-next themes/next Configuration_config.yml打开 ~/Desktop/Blog/themes/next/_config.yml 填入 # 控制主题导航栏显示内容 menu: home: / categories: /categories archives: /archives tags: /tags # 设置为紧凑型主题 scheme: Mist Navi目前导航栏中「分类」和「标签」是无法正常显示的 $ cd ~/Desktop/Joe $ hexo new page tags $ hexo new page categories 会在 ~/Desktop/Joe/source 下创建 tags 与 categories 目录 编辑 ~/Desktop/Joe/source/tags/index.md 写入 # 设置当前 page 类型为 tags type: &quot;tags&quot; # 设置当前页评论关闭 comments: false 编辑 ~/Desktop/Joe/source/categories/index.md 写入 # 设置当前 page 类型为 categories type: &quot;categories&quot; # 设置当前页评论关闭 comments: false 如果出现标签和分类页面的统计数据不正确的情况，按照以下步骤更新数据： 删除站点目录下的 db.json 文件 执行 hexo clean 重新生成 hexo g Avatar &amp; Favicon头像文件 default_avatar.jpg 放入 ~/Desktop/Joe/themes/next/source/iamges favicon 文件 favicon.ico 放入 ~/Desktop/Joe/themes/next/source 如果想用外部地址，配置Avatar请在 ~/Desktop/Joe/_config.yml 中加入 avatar: http://7xkgg5.com1.z0.glb.clouddn.com/Avatar/JUGG.jpg 配置favicon.ico请在 ~/Desktop/Joe/themes/next/_config.yml 中修改 favicon: http://7xkgg5.com1.z0.glb.clouddn.com/Avatar/favicon.ico Custom Variables~/Desktop/Joe/themes/next/source/css/_custom/custom.styl 中可以配置一些自定义变量，以达到修改样式的目的。下方列举其中几个变量： $font-family-headings = &quot;Microsoft YaHei&quot;, Verdana, sans-serif // 修改标题字体 $font-family-base = &quot;Microsoft YaHei&quot;, Verdana, sans-serif // 修改文章基本字体 $content-desktop = 700px // 修改文章内容的默认宽度 $font-family-monospace = Menlo,Monaco,&quot;Courier New&quot;,monospace // 修改代码块部分的字体 First Blog$ cd ~/Desktop/Joe $ hexo new firstblog 在 ~/Desktop/Joe/source/_posts 下生成 firstblog.md 文件并编辑 # 文章题目 title: 在GitHub上搭建基于Hexo的静态Blog # 所属分类 categories: - Web # 标签(多个标签如下所示) tags: - Hexo - GitHub - Disqus &lt;!-- more --&gt; 以上为文章列表显示摘要部分 正文书写参考 Markdown 语法 Generate$ cd ~/Desktop/Joe $ hexo generate // 生成静态文件 $ hexo server // 启动本地服务器 访问 http://localhost:4000 即可访问blog Hexo PluginsHexo 为我们提供了很多 Plugins ，让我们可以更专注于博客的内容书写 hexo-deployer-git用于git部署 $ cd ~/Desktop/Joe $ npm install hexo-deployer-git --save hexo-generator-sitemap生成sitemap便于搜索引擎抓取 $ cd ~/Desktop/Joe $ npm install hexo-generator-sitemap --save hexo-generator-feed便于RSS订阅 $ cd ~/Desktop/Joe $ npm install hexo-generator-feed --save Deployment只在本地可以看博客怎么会是我们的终极目的，下一步我们要将 blog 部署到 github 的仓库中 Repository登录 GitHub 账户，新建一个 repository Repository name 起成 name.github.io _config.yml打开 ~/Desktop/Blog/_config.yml 编辑 # 部署信息 deploy: type: git # https://github.com/GitHubName/RepositoryName.git repo: https://github.com/Joe-Hill/joe-hill.github.io.git branch: master Go!$ cd ~/Desktop/Joe $ hexo deploy 访问 https://RepositoryName (如 https://joe-hill.github.io) 即可访问Blog Domain name Resolution如果你拥有一个域名，比如 joehill.me 可以将其解析到你的Blog上 以域名joehill.me,DNS解析万网为例 创建一个 A 记录，主机记录为 @ ，解析线路选择默认，记录值为 103.245.222.133 ~/Desktop/Joe/source 下创建无扩展名内容为 joehill.me 文件 CNAME $ cd ~/Desktop/Joe $ hexo generate $ hexo deploy 等待解析成功，既可访问http://joehill.me Addition常用指令 $ hexo server $ hexo generate $ hexo deploy 可以简写成 $ hexo s $ hexo g $ hexo d 那么静态化 + 部署就可以写成 $ hexo d -g 开启你的美妙Blog之旅吧！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何让 Xcode 的 Debugger 灵活一点？]]></title>
      <url>%2F2015%2F04%2F20%2F2015-04-20-Xcode-Debugger%2F</url>
      <content type="text"><![CDATA[令人烦躁的 Xcode Debugger到底能不能聪明点啊？ Issue本文并不是讲述 LLDB 调试技巧， Skills系列，旨在解决一些开发中的一些小痛点，并非那些一定要掌握的知识。 但是如果你曾经不知道，在了解之后说不定还有点小兴奋呐。 一度特别怀念 Eclipse 的 Debugger，可以任意拖动，想放在自己想要摆放的位置。 为什么 Xcode 的就只能放在下方，每次当返回的内容较多的时候，就要手动调整 Debugger 的高度来查看返回内容，占用宝贵的代码部分显示区域。 本文目的就是可以让 Debugger 独立出来，放置在任何位置。 SolutionOutputXcode — 快捷键 command + , — Behaviors — Running — Generates output 默认情况下，如下显示 生成输出(Generates output)的选项卡下，只勾选了在当前页面显示 Debugger。 关闭默认选项，勾选在一个分离窗口，弹出一个名为 Console 的 Tab。 command + R运行，就会脱离原来的窗口，在一个新的窗口中弹出 Debugger。 toolbar、navigator、utilities都很烦，包括上方的代码区域。手动把 Debugger 上拉，占满整个窗口，并做如下设置 隐藏toolbar、navigator 和 utilities，再command + R，弹出的 Tab 就有点 Debugger 的样子了。 DebugXcode — 快捷键 command + , — Behaviors — Running — Pauses 按照如下设置，就会在新 Console 窗口中，显示变量部分、控制台部分以及调试导航部分。 command + R，从此你就可以愉快的 LLDB 调试啦。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[OpenWRT与ShadowSocks]]></title>
      <url>%2F2015%2F01%2F17%2F2015-01-17-OpenWRT-ShadowSocks%2F</url>
      <content type="text"><![CDATA[难道不想冲破天际看看外面的样子吗? Requirement 一台OpenWRT路由器 ShadowSocks luci-app-shadowsocks-spec pdnsd dnsmasq-full ipset,iptables What OpenWRT,嵌入式Linux发行版.非传统静态系统 ShadowSocks,代理通道 luci-app-shadowsocks-spec,在OpeWRT上为SS准备的图形配置界面 pdnsd,缓存DNS代理服务器 DNSmasq,把地址-域名映射关系放入cache中 ipset,iptables,配置域名标记 How 刷OpenWRT不在本文支持范围 ShadowSocks,采用aa65535编译版本.选择对应CPU下载. luci-app-shadowsocks-spec,pdnsd,DNSmasq,ipset,iptables皆由opkg获取 Go!opkgopkg是OpenWRT内置的source Manipulation update Update list of available packages upgrade &lt;pkgs&gt; Upgrade packages install &lt;pkgs&gt; Install package(s) configure &lt;pkgs&gt; Configure unpacked package(s) remove &lt;pkgs&gt; Remove package(s) flag &lt;flag&gt; &lt;pkgs&gt; Flag package(s) Informational Commands Informational Commands list List available packages list-installed List installed packages list-upgradable List installed and upgradable packages list-changed-conffiles List user modified configuration files files &lt;pkg&gt; List files belonging to &lt;pkg&gt; search &lt;file&gt; List package providing &lt;file&gt; find &lt;regexp&gt; List packages whose name or description matches pdnsdssh登入你的路由器 opkg update // 安装前务必update最新的list opkg install pdnsd cd /etc vi pdnsd.conf 配置下段代码 global { perm_cache=1024; cache_dir=&quot;/var/pdnsd&quot;; run_as=&quot;nobody&quot;; server_port = 1053; server_ip = 127.0.0.1; status_ctl = on; query_method=tcp_only; min_ttl=15m; max_ttl=1w; timeout=10; } server { label= &quot;googledns&quot;; ip = 8.8.8.8; root_server = on; uptest = none; } server_port = 1053;使用1053端口. query_method=tcp_only;只用tcp转发 ip = 8.8.8.8;转发ip 设置开机启动 /etc/init.d/pdnsd enable/etc/init.d/pdnsd restart 至此,pdnsd配置完毕 DNSmasq&amp;ipsetssh登入你的路由器 opkg updateopkg list-installeddnsmasq -v Dnsmasq version 2.71 Copyright (c) 2000-2014 Simon Kelley Compile time options: IPv6 GNU-getopt no-DBus no-i18n no-IDN DHCP DHCPv6 no-Lua TFTP no-conntrack ipset auth DNSSEC ipset即为支持ipset.如果不支持,请卸载当前dnsmasq,安装full版 opkg remove dnsmasqopkg install dnsmasq-fullopkg install ipset iptables-mod-nat-extra 安装完毕后 cd /etcvi dnsmasq.conf 最后一行,加入 conf-dir=/etc/dnsmasq.d 为保持代码整洁,在etc下新建dnsmasq.d文件夹,在dnsmasq.d下新建新的conf,在此暂命名为fuckgfw.conf vi /etc/dnsmasq.d/fuckgfw.conf 插入代码 server=/.live.com/127.0.0.1#1053ipset=/.live.com/fuckgfw server=/.live.com/127.0.0.1#1053代表将live.com转发1053端口,即之前配置好的pdnsd ipset=/.live.com/fuckgfw代表为改域名打上fuckgfw标记,缓存DNS至ip fuckgfw标记在iptables中用到 至此,DNSmasq和ipset配置完毕 ShadowSocks与Luci-ShadowSocks将aa65535编译好的ipk传至路由器/tmp下 opkg updateopkg install shadowsocksopkg install luci-app-shadowsocks-spec 在路由器的图形界面配置ShadowSocks对应参数. &#123; "server":"服务器地址", "server_port":8888, #服务器端口 "local_port":1080, #本地sock5代理端口 "password":"1111", "timeout":300, "method":"rc4-md5"&#125; 设置开机启动 /etc/init.d/shadowsocks enable ipset&amp;iptables先用ipset创建一个set,此处创建的名字为fuckgfw,然后将此set中所有ip都转发到ShadowSocks监听的1080端口. ipset -N fuckgfw iphashiptables -t nat -A PREROUTING -p tcp -m set --match-set fuckgfw dst -j REDIRECT --to-port 1080 建议将上述代码写入/etc/rc.local.每次开机自动运行. 重启DNSmasq /etc/init.d/dnsmasq restart Debug通过下面的命令查看set中的IP，这样可以确定解析是否正常，并且查看某网站是否正确的被加到了ipset ipset list fuckgfw 通过下面的命令可以清理掉set中所有ip ipset flush fuckgfw]]></content>
    </entry>

    
  
  
</search>
